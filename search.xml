<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法：有限状态机FSM</title>
      <link href="/2023/11/28/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BAFSM/"/>
      <url>/2023/11/28/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BAFSM/</url>
      
        <content type="html"><![CDATA[<p>Leetcode 137</p><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。</p><p>由于 “只有一个元素出现一次， 其他都是三次”， 那么假如我们 “数” 每一个二进制位上1出现的次数， 其最终结果必定如下图所示：</p><p><img src="https://shain001blog.oss-ap-southeast-2.aliyuncs.com/blogimage-20231128005230956.png" alt="image-20231128005230956"></p><p>也即， 每一个二进制位上， 1 出现的次数 对 3 求余的话， 其结果 要么是 0 （即 只出现一次的 数字在这一位上是0）， 要么是 1 （即 只出现一次的数字在这一位上 是1）。</p><p>为什么？ 因为“只有一个数字出现一次， 其他数字都是三次”， 这也就意味着， 每一位上1出现的次数， 只可能是 1, 3, 4(1+3), 6, 7(1+2*3)…</p><p>那么下一步我们只需要 遍历数组， 进行计算， 得到每一位上 1 出现的次数，对3求余， 即可 得到答案。</p><p>这样当然可以， 但是我们发现一个问题。 假设以上图为例， 某一个单个 位上的 1 的个数可能很大， 假如 数组中 有 1000 个数， 这个值可能是1000. 不好表示。那么不妨我们直接在遍历过程中 计算 某一个位上 1 的个数 对3 求余的 变化， 最终得到结果。</p><p>进一步讲， 当我们遍历完所有数字， 某一个位上 1 的个数对3 的余数 只有两种可能： 1 或者 0. </p><p>但是这是遍历完以后， 在遍历过程中， 由于我们要一个一个的遍历数字， 所以在过程中 一定会出现 对3余数为2的时刻。</p><p>也即， 每一位 对于3 求余 的余数 有三种可能性： 0，1，2</p><p>由于有三种状态， 那么我们需要表示为：</p><p>00 -&gt; 余数为0 ,     01 -&gt; 余数为1 ,     10-&gt; 余数为 2.</p><p><img src="https://shain001blog.oss-ap-southeast-2.aliyuncs.com/blogimage-20231128005230956.png" alt="image-20231128005230956"></p><p>以这张图为例。 我们遍历数组中， 所更新的 二进制数长成这样：</p><p>00 （代表左边第一列 1 的个数对3的余数） | 00 （左边第二列）| 00 | 00</p><p>即， 对于 每一个元素的二进制数上的每一位， 我们需要维护 一个 长度为 2 的二进制数 来记录其余数的变化。 </p><p>那么， 不妨将长度为 2 的二进制数拆开， 变成 高位和低位 两组 二进制数， 即：</p><p>high:  0 0 0 0</p><p>low: 0 0 0 0</p><p>此时， 对于上图中 对3 求余 的 二进制数 0101, 他实际上是  00, 01, 00, 01, —-&gt; 拆开成 high &amp; low:</p><p>high: 0 0 0 0</p><p>low: 0 1 0 1</p><p>不难发现， 当我们遍历完数组， 计算完 low and high以后， low所对应的值即为答案。 为什么？ 因为上面说的，  对三余数为2 的情况只是一个中间状态， 最终所有位上的1的个数 对三的余数 要么是 0， 要么是 1， 也即对应着状态 00 &amp; 01 </p><p>到这里， 我们要做的就仅仅是 遍历数组， 然后更新 high &amp; low.  他们的状态变化为下图所示 （下图中 two代表high， one对应low， 图是偷的）：</p><p><img src="https://shain001blog.oss-ap-southeast-2.aliyuncs.com/blogimage-20231128012054859.png" alt="image-20231128012054859"></p><p>也即， 当我们遍历到数组中一个新的元素， 要计算 low中或high中某一位的值， 要取决于 high 中 或 low中 对应的值当前为多少。 为什么？ 因为low 和high是拆开的嘛， 两者何在一起才能表示当前这一位上 1 的个数对三的余数为多少。</p><p>到这里我们能得到：</p><p>if high == 0: // 看上图， 如果 橘色代表的高位是 0 时， 当遍历的数字当前位为 1， low 是要取反的， 当遍历的数字当前位为0 则不变<br>  if n == 0:<br>    Low = low<br>  if n == 1:<br>    Low = ~low<br>if high == 1:<br>    Low = 0</p><p>引入 异或运算 ，可将以上拆分简化为：</p><p>if high == 0:<br>    Low = low ^ n<br>if high == 1:<br>    Low = 0<br>引入 与运算 ，可继续简化为：</p><p><strong>Low = low ^ n &amp; ~high</strong></p><p>对于 high的计算， 也是一样的公式。</p><p>这题的重点在于理解， high 和 low两个二进制数的意义， 即他们原本应该是写成： 00 | 00 | 00 | 00 | …… </p><p>但是为了计算方便， 所以拆成了两个二进制数high和low。 </p><p>其次在于理解， 为什么计算结束后， low代表的值即为答案。</p><p>最后则是理解 位运算的公式推导过程。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法：数组寻找重复数字-1</title>
      <link href="/2023/11/12/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E7%BB%84%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97-1/"/>
      <url>/2023/11/12/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E7%BB%84%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97-1/</url>
      
        <content type="html"><![CDATA[<h1 id="寻找数组中重复数字"><a href="#寻找数组中重复数字" class="headerlink" title="寻找数组中重复数字"></a>寻找数组中重复数字</h1><h3 id="元素值与下标有对应关系"><a href="#元素值与下标有对应关系" class="headerlink" title="元素值与下标有对应关系"></a>元素值与下标有对应关系</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Two Random Algorithm</title>
      <link href="/2023/09/10/Two-Random-Algorithm/"/>
      <url>/2023/09/10/Two-Random-Algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="两个取随机数算法"><a href="#两个取随机数算法" class="headerlink" title="两个取随机数算法"></a>两个取随机数算法</h1><h2 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h2><p>即给你一个数组， 要求你<strong>打乱</strong>这个数组。 也可应用于“扫雷这种类型， 例如 随机在数组中的几个位置生成雷”。</p><h3 id="如何确定-验证算法所打乱的数组真的是随机的？"><a href="#如何确定-验证算法所打乱的数组真的是随机的？" class="headerlink" title="如何确定/验证算法所打乱的数组真的是随机的？"></a>如何确定/验证算法所打乱的数组真的是随机的？</h3><p><strong>通过结果的可能性的数量来确定是不是真的打乱了</strong></p><p>即， 对于一个长度为n的数组， <strong>对其进行 全排列 的结果可能性数量为 n!。</strong></p><p>那么只要保证算法所打乱的数组， 也有n！中可能性即可确定 算法被打乱的数组 真的被打乱了。 </p><p><strong>注意：洗牌算法目的在于‘打乱’数组， 正确性自然是通过 排列组合总数证明的！</strong> </p><p>理解以后直接看代码实现即可。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShuffleAlgorithm_L384</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShuffleAlgorithm_L384</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] copy = Arrays.copyOf(nums, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">          <span class="comment">// 对于每个下标i， 其可能被交换到的下标范围为 [i, len-1], 即 n-i, where i 为下标</span></span><br><span class="line">            <span class="comment">// (len-1 - i + 1), +1 因为下标从0 开始</span></span><br><span class="line">            <span class="keyword">int</span> randomIndex = random.nextInt(i, nums.length);</span><br><span class="line">            swap(copy, i, randomIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><p>不难发现， 该算法只能处理 数组长度已知并且长度不变的情况 (当然也很正常， 因为这个算法的目的就是打乱一个数组)。</p><p>那么对于扫雷游戏中随机地点生成地雷这种需求， 虽然也可以利用这个算法“将地雷随机分配到某个地点”（先将x个地雷全部放到数组头部， 然后打乱数组， But what if 你不知到元素总量， you may say 我可以遍历两次数组， 第一次遍历数有多少元素， 第二次再选取， 但是如果数组长度是动态的呢？ 例如遍历了第一次数组以后， 数组长度就变化了。—&gt; This is where reservior algorithm should be used.</p><h1 id="蓄水池算法-Reservior-Algorithm"><a href="#蓄水池算法-Reservior-Algorithm" class="headerlink" title="蓄水池算法 Reservior Algorithm"></a>蓄水池算法 Reservior Algorithm</h1><p>蓄水池算法目的是“随机抽样”， 并且算法无需知道 元素总量是多少， 也无需样本数量固定。 </p><p>这意味着对于streaming data, 该算法依然可以生效。</p><p>那么要证明算法选取的样本真的是随机的， 自然是证明每个样本被选择的概率都是 1/n.</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>算法通过简单的数学运算实现， <strong>首先要理解的一个point是： “假设只需选取一个元素， instead of 只选取一次， 算法会对每个元素都进行 ‘选与不选’的判断， 即 加入 1-10 是个数字中， 已经选取了1， 对于剩下的 2-9 也可能会再次选取， 只不过 如果又选到了2， 那么原本选取的 1 就不要了 ”</strong></p><p>进而不难发现， <strong>假设最终成为答案的样本编号为 k，那么 k 成为答案的充要条件为「在遍历到 k 时被选中」并且「遍历大于 k 的所有元素时，均没有被选择（没有覆盖 k）」 。</strong></p><p><strong>具体做法为：从前往后处理每个样本，每个样本成为答案的概率为 1/i （i 位样本 编号， 从1 开始）</strong> </p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p><strong>对于每一个样本 i， 由于其最终成为答案的 条件为： 「在遍历到 k 时被选中」并且「遍历大于 k 的所有元素时，均没有被选择（没有覆盖 k）」</strong> 那么其对应的概率为：</p><p><img src="https://shain001blog.oss-ap-southeast-2.aliyuncs.com/blogimage-20230910224309928.png" alt="image-20230910224309928"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservoirAlgorithm_L382</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line">    <span class="keyword">private</span> ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReservoirAlgorithm_L382</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">        <span class="keyword">this</span>.random = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode p = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// radom.nextInt取值左闭右开</span></span><br><span class="line">            <span class="keyword">if</span> (random.nextInt(<span class="number">0</span>, count) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.result = p.val;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p = p.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bit calculation &amp; Rabin-Karp Algorithm</title>
      <link href="/2023/08/27/bit-calculation-Rabin-Karp-Algorithm/"/>
      <url>/2023/08/27/bit-calculation-Rabin-Karp-Algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="将字符串映射成-N-进制数字，-然后再转成10进制存储"><a href="#将字符串映射成-N-进制数字，-然后再转成10进制存储" class="headerlink" title="将字符串映射成 N 进制数字， 然后再转成10进制存储"></a>将字符串映射成 N 进制数字， 然后再转成10进制存储</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// R 为 N</span></span><br><span class="line"><span class="comment">// L 为 字符串长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> R;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> L;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">addToRight</span><span class="params">(<span class="keyword">int</span> hash, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash * R + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">removeFromLeft</span><span class="params">(<span class="keyword">int</span> hash, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash - n * (<span class="keyword">int</span>) Math.pow(R, L-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果忘了， 就拿十进制举例子。 将“123” 变成int 123 怎么变？ 1 * 10 + 2 -&gt; 12;  12* 10 + 3 -&gt; 123; </p><p>将123中的1 移除变成23 怎么移？ 123 - 1 * 100;  此处的100 即 10^2</p><p>即这里的 addToRight &amp; removeFromLeft 方法实际上就是在直接进行 进制转换。 举个例子： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">二进制数 1101 转换成 十进制怎么算？</span><br><span class="line"></span><br><span class="line">1 1 0 1</span><br><span class="line">1 * 2^3 + 1* 2^2 + 0 * 2^1 + 1 * 2^0</span><br></pre></td></tr></table></figure><h3 id="进制R的值怎么确定？"><a href="#进制R的值怎么确定？" class="headerlink" title="进制R的值怎么确定？"></a>进制R的值怎么确定？</h3><p>每一位上的值有几种可能性就是几进制。</p><h3 id="例题-leetcode187"><a href="#例题-leetcode187" class="headerlink" title="例题 - leetcode187"></a>例题 - leetcode187</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shain.array.limitedComplexity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindRepeat_L187</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> L = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> test = <span class="keyword">new</span> FindRepeat_L187();</span><br><span class="line">        System.out.println(test.findRepeatedDnaSequences_v2(<span class="string">&quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基础方法， 时间复杂度，空间复杂度均为 O(NL) where N is length of String, L is length of window.</span></span><br><span class="line"><span class="comment">     * Why O(NL)?</span></span><br><span class="line"><span class="comment">     * for遍历N次， 每次遍历都要进行substring操作， substring的长度为L， 进而记为O(NL)， 实际上可以取为O(N)， 但是这里强调 NL 的目的为</span></span><br><span class="line"><span class="comment">     * 理解对其进行的优化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 空间复杂度为O(NL)好理解， key为String， 共N个key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 仅用滑动窗口优化？</span></span><br><span class="line"><span class="comment">     * 没用， 就算加入滑动窗口， 记录窗口内的字符串， 然后将其进行toString, toString 这个操作仍然是O(L)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * e.g.</span></span><br><span class="line"><span class="comment">     * String windowStr = window.toString();</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 同时这样的方案无法优化空间复杂度到真正的 O(N);</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - L; ++i) &#123;</span><br><span class="line">            String sub = s.substring(i, i + L);</span><br><span class="line">            cnt.put(sub, cnt.getOrDefault(sub, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (cnt.get(sub) == <span class="number">2</span>) &#123;</span><br><span class="line">                ans.add(sub);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用对字符串进行HASH 来优化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> R;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences_v2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] converted = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        Map&lt;Integer, Integer&gt; occured = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Since There is only 4 possible values ACGT, 所以是四进制</span></span><br><span class="line">        <span class="comment">// 注意理解这个hash的过程， 由于只有四种可能的核苷酸值， 所以每一位的值就只有四种可能性。</span></span><br><span class="line">        <span class="comment">// 也即， 将一个窗口中的字符串， 转换成了一个长度为L的四进制数</span></span><br><span class="line">        <span class="comment">// 然后又将这个四进制数转换成了十进制的值作为hash</span></span><br><span class="line">        <span class="comment">// 也即这种方法是将一个字符串， 先转换成一个 R 进制的数字， 再将其转换成10进制保存。</span></span><br><span class="line">        R = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Character c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: converted[i++] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: converted[i++] = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>: converted[i++] = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: converted[i++] = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            hash = addToRight(hash, converted[right]);</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right - left == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (occured.getOrDefault(hash, <span class="number">0</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    result.add(s.substring(left, right));</span><br><span class="line">                &#125;</span><br><span class="line">                occured.put(hash, occured.getOrDefault(hash, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                hash = removeFromLeft(hash, converted[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">addToRight</span><span class="params">(<span class="keyword">int</span> hash, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hash * R + n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">removeFromLeft</span><span class="params">(<span class="keyword">int</span> hash, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hash - n * (<span class="keyword">int</span>) Math.pow(R, L-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="正常的java位运算：左移右移与或等"><a href="#正常的java位运算：左移右移与或等" class="headerlink" title="正常的java位运算：左移右移与或等"></a>正常的java位运算：左移右移与或等</h1><h3 id="与上述方法的异同"><a href="#与上述方法的异同" class="headerlink" title="与上述方法的异同"></a>与上述方法的异同</h3><p>正常的 java 位运算， 实际相当于把 “上一个方法中的， 将2进制转换为10进制这一个过程让java自动完成了”， 同时它有一个局限是， 只能操作2进制的数字。 换句话说， 如果要将 Leetcode187 用 这种正常的位运算来做的话， 那么 ACGT 对应的hash值分别应为： 00, 01, 10, 11</p><p>这样有个缺点， 即， 对于一个长度为10 的字符串， 这种方法所转换出来的数字占用20个字节， 但是上个方法占用10个字节。虽然10个字节与20个字节， int都能够表示， 但是如果是长度为100的字符串呢？</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="左移-右移-lt-lt-gt-gt"><a href="#左移-右移-lt-lt-gt-gt" class="headerlink" title="左移 右移 &lt;&lt; &gt;&gt;"></a>左移 右移 &lt;&lt; &gt;&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">5</span> &lt;&lt; <span class="number">2</span>); <span class="comment">// 输出20</span></span><br></pre></td></tr></table></figure><p>5 = 0101 (开头的0 为符号为)</p><p>左移两位后：</p><p>010100 = 1 * 2^4 + 1 * 2 ^ 2 = 20</p><h3 id="按位与-或-amp"><a href="#按位与-或-amp" class="headerlink" title="按位与/或 &amp; |"></a>按位与/或 &amp; |</h3><p>略。 </p><p>但是注意 通过 “将 ‘左/右移 ’  与 ‘按位 与或’ 结合改变 二进制中某一个特定值的操作。</p><p>例如， 利用二进制存储某个用户一年中的登陆信息， 要改变 二进制中某一个bit的值， 则需利用这种操作</p><h3 id="无符号-左移-右移"><a href="#无符号-左移-右移" class="headerlink" title="无符号 左移 右移"></a>无符号 左移 右移</h3><p><img src="https://shain001blog.oss-ap-southeast-2.aliyuncs.com/blogimage-20230826235752678.png" alt="image-20230826235752678"></p><h3 id="取反-～"><a href="#取反-～" class="headerlink" title="取反 ～"></a>取反 ～</h3><p>一元操作， 自身取反， 不太用的到。</p><p>这里涉及到 二进制符号位等等问题， 不看了，感觉用不着。</p><h1 id="Robin-Karp-算法"><a href="#Robin-Karp-算法" class="headerlink" title="Robin-Karp 算法"></a>Robin-Karp 算法</h1><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>用于 在文本中 匹配目标字符串。</p><h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p>实际上就与第一种hash方法一样。 通过将pattern 字符串进行hash， map中的空间复杂度。</p><p>同时， 由于用了hash， 再结合滑动窗口， 那么在匹配过程中的时间复杂度也从 O(NL) 优化到了 O(N). （如果忘了为什么是NL看上面的代码注释）。</p><p>换句话说， 上面的Leetcode187 其实就是简易版的 Robin-Karp 算法。</p><p>为什么说是简易版？ 因为 Robin-Karp算法需要对hash后的十进制数进行mod, 同时mod以后就可能产生hash冲突， 进而在发现 当前hash值已经出现过以后， 需要 进行 “暴力遍历” 判断来确定 找到的字符串是不是跟pattern串一样。</p><h3 id="关于mod"><a href="#关于mod" class="headerlink" title="关于mod"></a>关于mod</h3><p>为什么Robin-Karp 需要mod? 因为， L187 中每个字符只有四种取值， 但是 实际的 ASCII 码有 256种取值 （因为ASCII 取值 0 - 255）。</p><p>Which means, 一个长度为L 的字符串， 每一位有 256 种取值可能性， 也就是 hash后， 所得的数字是 256 进制的， 而 当L值很大时， int/long 肯定都是装不下的。 </p><p>e.g. L = 1000, -&gt; 则所得的十进制数范围为 1000^256</p><p>所以我们要做的就是缩小 转换为十进制以后的hash值的范围， 进而需要进行mod操作。</p><p>而这个 被余的数 P 可以是 1658598167 ， 也可以是别的数， 但是要是尽可能大的素数 （涉及数学知识， 不仔细看了）</p><h3 id="关于-被余数-P-的选择"><a href="#关于-被余数-P-的选择" class="headerlink" title="关于 被余数 P 的选择"></a>关于 被余数 P 的选择</h3><p><strong>为什么要这个 <code>Q</code> 尽可能大呢？主要是为了降低哈希冲突的概率</strong>。</p><p>因为代码中你把这个 <code>Q</code> 作为除数，余数（哈希值）一定落在 <code>[0, Q-1]</code> 之间，所以 <code>Q</code> 越大，哈希值的空间就越大，就越不容易出现哈希冲突，整个算法的效率就会高一些。</p><p><strong>为什么这个 <code>Q</code> 要是素数呢？依然是为了降低哈希冲突的概率</strong>。</p><p>举个极端一点的例子，你令 <code>Q = 100</code>，那么无论一个数 <code>X</code> 再大，<code>X % Q</code> 的结果必然是 <code>X</code> 的最后两位。换句话说 <code>X</code> 前面的那些位你根本没利用，可想而知你这个哈希算法存在某些规律性，不够随机，进而更容易导致哈希冲突，降低算法的效率。</p><h3 id="代码-（copy的）"><a href="#代码-（copy的）" class="headerlink" title="代码 （copy的）"></a>代码 （copy的）</h3><p>// Rabin-Karp 指纹字符串查找算法<br>int rabinKarp(String txt, String pat) {<br>    // 位数<br>    int L = pat.length();<br>    // 进制（只考虑 ASCII 编码）<br>    int R = 256;<br>    // 取一个比较大的素数作为求模的除数<br>    long Q = 1658598167;<br>    // R^(L - 1) 的结果<br>    long RL = 1;<br>    for (int i = 1; i &lt;= L - 1; i++) {<br>        // 计算过程中不断求模，避免溢出<br>        RL = (RL * R) % Q;<br>    }<br>    // 计算模式串的哈希值，时间 O(L)<br>    long patHash = 0;<br>    for (int i = 0; i &lt; pat.length(); i++) {<br>        patHash = (R * patHash + pat.charAt(i)) % Q;<br>    }</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口中子字符串的哈希值</span></span><br><span class="line"><span class="keyword">long</span> windowHash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动窗口代码框架，时间 O(N)</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (right &lt; txt.length()) &#123;</span><br><span class="line">    <span class="comment">// 扩大窗口，移入字符</span></span><br><span class="line">    windowHash = ((R * windowHash) % Q + txt.charAt(right)) % Q;</span><br><span class="line">    right++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当子串的长度达到要求</span></span><br><span class="line">    <span class="keyword">if</span> (right - left == L) &#123;</span><br><span class="line">        <span class="comment">// 根据哈希值判断是否匹配模式串</span></span><br><span class="line">        <span class="keyword">if</span> (windowHash == patHash) &#123;</span><br><span class="line">            <span class="comment">// 当前窗口中的子串哈希值等于模式串的哈希值</span></span><br><span class="line">            <span class="comment">// 还需进一步确认窗口子串是否真的和模式串相同，避免哈希冲突</span></span><br><span class="line">            <span class="keyword">if</span> (pat.equals(txt.substring(left, right))) &#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缩小窗口，移出字符</span></span><br><span class="line">        windowHash = (windowHash - (txt.charAt(left) * RL) % Q + Q) % Q;</span><br><span class="line">        <span class="comment">// X % Q == (X + Q) % Q 是一个模运算法则</span></span><br><span class="line">        <span class="comment">// 因为 windowHash - (txt[left] * RL) % Q 可能是负数</span></span><br><span class="line">        <span class="comment">// 所以额外再加一个 Q，保证 windowHash 不会是负数</span></span><br><span class="line"></span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有找到模式串</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一需要注意的就是 </p><p>X % Q == (X + Q) % Q 这个模运算法则</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>差分</title>
      <link href="/2023/08/26/%E5%B7%AE%E5%88%86/"/>
      <url>/2023/08/26/%E5%B7%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://shain001blog.oss-ap-southeast-2.aliyuncs.com/blogimage-20230826201244930.png" alt="image-20230826201244930"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DP: Continus SubArray</title>
      <link href="/2023/07/27/DP-Continus-SubArray/"/>
      <url>/2023/07/27/DP-Continus-SubArray/</url>
      
        <content type="html"><![CDATA[<h1 id="Temp"><a href="#Temp" class="headerlink" title="Temp"></a>Temp</h1><p>数组d相当于记录了所有 长度为 index的 子数组。</p><p>But the tricky part is it only records the tail for each of them.</p><p>See the example below.</p><p>The reason you do this, is that, it can keep you array d increasing.</p><p>Why? </p><p>e.g. for n1 &amp; n2. if n1 &lt; n2, then, 以n1 结尾的升序子数组的长度， 一定小于 以n2结尾的升序子数组长度。 </p><p>Which means: </p><ol><li>d数组一定是升序的， 但是前提条件是 d数组中， 对于 各个长度一样的 子数组， 一定记录 最小的tail值。</li></ol><p>重点在于理解 d数组实际的含义， 以及， 为什么d数组一定是递增的。</p><p>进而 it’s easy to realize the Binary Search Thing.</p><p>More about why 对于一样len的子数组， 一定将tails中元素记录更小的值。</p><p>e.g. [10, 3, 8]</p><p>当遍历到 index = 1， 即nums[i] = 3 时， 此时d[1] = 10; 而 元素3的长度也是1， 但是由于3&lt;10, 所以以10 结尾的 子数组必定不会长过以3小的子数组。</p><p><img src="https://shain001blog.oss-ap-southeast-2.aliyuncs.com/blogimage-20230727155405802.png" alt="image-20230727155405802"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tails;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        tails = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        tails[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">this</span>.len = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; tails[len]) &#123;</span><br><span class="line">                tails[++len] = nums[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = getIndex(nums[i]);</span><br><span class="line">            tails[index] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 二分找 第一个比target大的下标。</span></span><br><span class="line">   <span class="comment">// 进而直接将return的下标更新为nums[i] 即可。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="keyword">this</span>.len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tails[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法：DP-SubArrary</title>
      <link href="/2023/06/26/%E7%AE%97%E6%B3%95%EF%BC%9ADP-SubArrary/"/>
      <url>/2023/06/26/%E7%AE%97%E6%B3%95%EF%BC%9ADP-SubArrary/</url>
      
        <content type="html"><![CDATA[<p>L</p><p>1035 -&gt; 详见repo中的笔记summary</p><p><img src="https://shain001blog.oss-ap-southeast-2.aliyuncs.com/blogblogimage-20230626220734192.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-回溯</title>
      <link href="/2023/06/11/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%89%8B-%E5%9B%9E%E6%BA%AF/"/>
      <url>/2023/06/11/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%89%8B-%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯问题总结："><a href="#回溯问题总结：" class="headerlink" title="回溯问题总结："></a>回溯问题总结：</h1><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><p><img src="https://shain001blog.oss-ap-southeast-2.aliyuncs.com/blogimage-20230611224057808.png" alt="image-20230611224057808"></p><h4 id="Used-VS-start"><a href="#Used-VS-start" class="headerlink" title="Used[] VS start"></a>Used[] VS start</h4><p>两者主要区别：</p><ul><li><p>used 可使 “同一层级中， 所有节点的分支数统一减少‘一定’数量”。 如上图右侧部分， L1 中 1， 2， 3 下的节点均因used[] 减少了一， 进而使得每个节点下的分支中， 不包含自身 （i.e. L1中 1 节点下的分支中不再包含 1 本身）</p><ul><li>p.s. 之所以说减少 ‘一定数量’， 因为理论上不一定是仅仅减少1， 比如， 可以通过used[] 的设置， 使得L1 的 1 节点下 的分支中， 也不包括 2。 但还没遇到过这种题。</li></ul></li><li><p>Start 主要作用仅仅是 “使得统一层级中的节点 x1, x2, x3, x4… (从左到右数， x1 在x2 的左侧， x2在x3的左侧… )，Xn 下的分支中， 不包含 X1-n-1 中出现的所有元素， 进而表现为 同一层级中 从左至右， 每个节点下的分支数量 依次减少”， 例子如上图。</p><ul><li><p>需要注意的是， 一旦使用了start， 必定会使得 Xn 节点下的分支中，不包括所有 X1- Xn-1 节点中的元素。 即， 如上图， 使用了start以后， L1 的 3 节点下面， 不包含1， 也不包含2， 只剩下了3。 “这意味着， 如果 你想要 一个节点下的分支中不包含自己， 但是要包含除了自己以外的所有元素， 你需要使用 used， 而不是start，因为这会使得一个节点下丢失更多的元素。” 一个例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(LinkedList&lt;Integer&gt; path, <span class="keyword">int</span> curSum, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 此处i+1 确实使得当前节点下的分支中不包含自己， 但是也 排除了所有 0-i 之间的元素。</span></span><br><span class="line">            backtrack(path, curSum, i+<span class="number">1</span>);</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="old"><a href="#old" class="headerlink" title="old"></a>old</h2><p>无非三种情况：</p><ul><li><p>同一层级中， 每个节点的分支数相同。 –&gt; 使用 used[] 改变状态，不使用 start作为 递归方程的参数。 </p><ul><li>e.g.  leetcode 全排列1，2</li></ul></li><li><p>同一层级中， 每个节点的分支数不相同， 即同一层级中， 节点2 的分支中不包含节点1的元素， 同理， 节点三的分支中不包含节点1，2两个节点的元素。 –&gt; 使用 start 作为 递归方程的参数， 进而改变for循环开始位置， 即从start开始， 即：</p><ul><li>e.g. leetcode 39</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start):</span><br><span class="line">  back_track(start=i, xxx)</span><br></pre></td></tr></table></figure><ul><li>各层单个节点下分支数量相同， 但是在单个层中， 每个节点的元素数量在变化， 并且 输入元素的顺序不改变。 语言不好理解， 我想表达的是 Leetcode 93. IP地址， 以及offer46 的这种类型； （offer46 应用DP求解， 但bt也可以做， 只不过效率低）<ul><li>对于这种类型， 格式也较为固定，代码框架如下。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ip_config</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back_track</span>(<span class="params">remained_s, ip, ip_seg, count</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 剪枝条件</span></span><br><span class="line">        <span class="keyword">if</span> .....</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">1</span>:</span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># ！！！！重点在这个for循环， 此处， i的范围， 表示 ”单个节点内， 元素数量的可能性“</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">            ip_seg = remained_s[<span class="number">0</span>:i] + <span class="string">&quot;.&quot;</span></span><br><span class="line">            temp = ip + ip_seg</span><br><span class="line">            back_track(remained_s[i:], temp, ip_seg, count - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; <span class="number">4</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) &gt; <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    to_return = []</span><br><span class="line">    back_track(s, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> to_return</span><br></pre></td></tr></table></figure><p>通常， abc 不等同于 acb时， 则需使用情况1， 即使用used， 使分支数相同。 而若 abc 等同于 acb， 即顺序无关， 则应使用 情况2， 避免重复解。 </p><p>之所以情况二可以避免重复解，画个树， 或者举个例子即可明白。 简单说， e.g. 2为最上层节点， 其一条分支为 2， 2， 3； 那么到了最上层的2的同级节点3以后， 就不应该再在3的分支中包括2， 因为这样一定会出现一条分路 3， 2， 2，进而造成重复。</p><p>More About used：</p><p>Used 的作用即为： 控制单个节点下的分支个数，也即单个节点下的分支有哪些节点。 比如， 一个节点的分支中， 应不应该有自己？ 此时则应用used控制， 通过 递归前， 后的更改/还原状态控制。 </p><p>注意， used和start并非不可同时使用， 看情况判断。</p><h2 id="关于求子集问题"><a href="#关于求子集问题" class="headerlink" title="关于求子集问题"></a>关于求子集问题</h2><p>即 offer38 的扩展题。  输入123， 输出： 1， 2， 3， 12， 13， 23， 123</p><p><strong>即不仅仅输出“一条到叶子节点的路线”， 也要输出第一层， 第一层+第二层， 第一层+ 第二层+ … + 第n层</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subset</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back_track</span>(<span class="params">start, path</span>):</span></span><br><span class="line">      <span class="comment"># 载递归函数入口就将path加到result上即可。</span></span><br><span class="line">        to_return.append(path[:])</span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(s) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> used[i] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">                back_track(i, path + [s[i]])</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    used = [<span class="literal">False</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">    to_return = []</span><br><span class="line">    back_track(<span class="number">0</span>, [])</span><br><span class="line">    <span class="keyword">return</span> to_return</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该问题相当于 上文中情况1， 2的结合使用。 即所说的used和start的同时使用的情况的例子。</p><p>唯一需要注意的是： 这一问题的特殊点在于不仅仅输出 到 叶子节点的完整路线， 也要输出“从第一层节点， 到每一个节点的temp 路线”。 实现原理很简单， 在函数入口 直接 append就可以。 </p><p>之所以这么实现， 是因为每调用一次 backtrack() , 就是向下创建了一层， 到达了一个新的子节点。 而此时， path中已经更新了当前这个新的叶子节点的值， 那么只需要直接append path to result， 就相当于实现了 “第一层节点， 到每一个节点的temp 路线都被记录下来”这一目的。</p><p> 如下图， 每call一次 backtrack， 就创建了一个新的子节点， 也即一条edge。 也即， 要记录从第一层节点到每一层节点的路径， 只需要在backtrack路口处添加path到result就可以。</p><p><img src="C:\Users\Senry\Desktop\bt.png" alt="bt"></p><h2 id="复杂些的问题-搜索问题？"><a href="#复杂些的问题-搜索问题？" class="headerlink" title="复杂些的问题 - 搜索问题？"></a>复杂些的问题 - 搜索问题？</h2><p>大概率从剪枝条件入手创造难度。</p><h1 id="补充：重复元素问题"><a href="#补充：重复元素问题" class="headerlink" title="补充：重复元素问题"></a>补充：重复元素问题</h1><p>看intellij 代码注释。</p><p>L47: 通过used 排除同一层级中的重复元素。</p><p>L40: 没有used数组， 只用了start， 怎么排除？</p><p><img src="https://shain001blog.oss-ap-southeast-2.aliyuncs.com/blogimage-20230913212721225.png![image-20230913213234066](https://shain001blog.oss-ap-southeast-2.aliyuncs.com/blogimage-20230913213234066.png" alt="image-20230913212721225"></p><p>首先， 重复的元素在排序以后一定是 i &gt; 0 &amp;&amp; nums[i] == nums[i-1]</p><p>但是像 L47注释中写的， 只利用这一条件跳过重复元素会 错误的 漏掉 “不同层级， 但是val相同的节点。”</p><p>那么我们不妨看看， 这些被错误漏掉的节点都是谁？ 上图中可发现， 其实被错误漏掉的 只有 L2.A 的这个1。</p><p>为什么？ 因为 L2.B 的这个 1 本来就属于同一层级中的相同元素， 即本来就是应该被略过的。</p><p>因此， 其实我们只需要保留 到 L2.A 的这个1 就可以了，而这个 1 的条件是什么？ —&gt; i == start </p><p>那么， 除了这个 1 以外的 1 全部都排除， 自然就能排除所有同一层级的 重复元素， 也即 将 i==start 取反， 得到 i &lt; 0 || i &gt; start, 而 i 又不可能小于start， 所以得到： 只要是 i &gt; start, 并且 nums[i] == nums[i-1] 的元素全部是 应该排除的重复元素。</p><p>问， 那么 L2.c 中的2 会被正确保留吗？ –&gt; 当然， 因为 对于 L2.C 这个 2， 不满足 nums[i] == nums[i-1] 。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> BackTrack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtrack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm:DP1.1-bottomUpTraverse</title>
      <link href="/2023/05/27/Algorithm-DP1-1-bottomUpTraverse/"/>
      <url>/2023/05/27/Algorithm-DP1-1-bottomUpTraverse/</url>
      
        <content type="html"><![CDATA[<h2 id="L514"><a href="#L514" class="headerlink" title="L514"></a>L514</h2><p><img src="https://shain001blog.oss-ap-southeast-2.aliyuncs.com/blogimage-20230527223654700.png" alt="image-20230527223654700"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shain.dp.pathSum.bottomUpTraverse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreedomTrail_L514</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(findRotateSteps(<span class="string">&quot;godding&quot;</span>, <span class="string">&quot;godding&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key point:</span></span><br><span class="line"><span class="comment">     * 1. 明确需两个指针i，j 分别指向 key and ring。 要移动j，使当前j 指向的字符等于 k指向的key。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 2. KEY POINT:</span></span><br><span class="line"><span class="comment">     * 而要使 当前的两个指针达到这种状态，对于当前j而言， 有 n 种选择， n等于 ring 中出现 key[i] 的次数。</span></span><br><span class="line"><span class="comment">     * 换句话说，即相当于建立一个n叉树， 从一个 虚拟头节点开始， 有n个子节点。每个子节点 又 分出n个子节点。  （todo：见图）</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 每个子节点的value， 则是 从 当前 ring[j]开始，使得 所有key [i：-1] 找到对应的ring[j]所需的最小移动步数之和。也即 min(到达各个子节点的路径值curMin + 各个子节点的value）</span></span><br><span class="line"><span class="comment">     * 发现问题了么？ Node 的value 指的是， 当前节点下的所有子路径的最小和。 也即， 要先计算 所有子节点的value， 才能得到 node 的</span></span><br><span class="line"><span class="comment">     * value。&quot;也即后序遍历&quot;， &quot;因为在 前序遍历过程中（上到下遍历）， 你无法得到子节点的value, 只能得到curMin， 所以只能从下往上遍历所有路径&quot;，</span></span><br><span class="line"><span class="comment">     * 这就是所谓的 &quot;当前的状态， 依赖于后面的状态， 但是并不依赖于父节点的状态&quot;。 这就是为什么 &quot;需要倒序的更新dpTable的原因&quot;。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 反之，如果我们要求的值是所有 curMin 的最小和， 那么可以进行 前序遍历，因为对于curMin的和， 只需要在 向下遍历到每一个节点的时候， 就可以得到（当然， 也是可以</span></span><br><span class="line"><span class="comment">     * 进行后序遍历的， 这就是为什么 二维表格类型的dp题， 基本都可以后序遍历）。 这就是为什么 L64, L174这种题可以正向更新dp数组， 但是 L174 和</span></span><br><span class="line"><span class="comment">     * L 514这种题必须 逆序更新dp数组。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 如果你还是不明白上文讲的 curMin 的和 vs Value 的和 的区别， 即如果你不明白为什么  Sum（curMin） 可以正向求， sum(value)必须逆向求。</span></span><br><span class="line"><span class="comment">     * 那么想象你站在头节点：</span></span><br><span class="line"><span class="comment">     * &quot;当你第一次 去到 1号子节点， 你能知道 value 的值吗？ 不能，因为他需要先走到 所有 leaf Node 再回来才知道&quot;</span></span><br><span class="line"><span class="comment">     * &quot;当你第一次 去到 1号子节点， 你能知道 curMin的值吗？ 能， 因为curMin不取决于子节点。你可以直接得到当前curMin的值&quot;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 此处的curMin， 其实就相当于 L64 这种题中的 每个格子的 值， 你可以直接在 从 头节点遍历到叶子节点的过程中 得到所有 curMin的和。所以可以正向</span></span><br><span class="line"><span class="comment">     * 更新dp。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 3. 当然， 对于这道题本身而言， you also should realize that curMin的最小路径和， 不等同于value的最小路径和。 but you got this</span></span><br><span class="line"><span class="comment">     * when you first saw the question, so I believe you should be fine.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 4. dpTable的定义：</span></span><br><span class="line"><span class="comment">     * 从 j = x 开始运动， 使得 key[i:-1] 全部被对应所需要的最小值。 其中， x 代表父节点的j值。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 6. Another Key Point:</span></span><br><span class="line"><span class="comment">     * dp数组如何初始化？ 答： 可以初始化成 ring.length+1 * key.length+1 的数组。</span></span><br><span class="line"><span class="comment">     * 第 ring.length+1 列，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ring</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRotateSteps</span><span class="params">(String ring, String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[key.length() + <span class="number">1</span>][ring.length()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立hashtable 存储 ring中所有字符对应的index. 由于有重复字符， 所以value是list。</span></span><br><span class="line">        Map&lt;Character, List&lt;Integer&gt;&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ring.length(); i++) &#123;</span><br><span class="line">            hash.putIfAbsent(ring.charAt(i), <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            hash.get(ring.charAt(i)).add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i -&gt; 当前要找到的key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = key.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// j -&gt; 父节点的j值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= ring.length() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                List&lt;Integer&gt; indexes = hash.get(key.charAt(i));</span><br><span class="line">                <span class="comment">// line74 的遍历过程， 即相当于遍历一个父节点的所有子节点的过程。</span></span><br><span class="line">                <span class="comment">// 在这一过程中， 计算了所有到达子节点所需的 &quot;路径值&quot;， 也即curMin。</span></span><br><span class="line">                <span class="comment">// 当前节点的value = min(到达各个子节点的路径值curMin + 各个子节点的value）</span></span><br><span class="line">                <span class="comment">// !!注意， value的含义是 从当前节点出发， 到所有叶子节点的路径 的最小值， 对于一个节点的value， 是不包含当前节点的curMin的。</span></span><br><span class="line">                <span class="keyword">int</span> curValue = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span> (Integer index : indexes) &#123;</span><br><span class="line">                    <span class="keyword">int</span> pos = Math.abs(j - index);</span><br><span class="line">                    <span class="keyword">int</span> neg = ring.length() - pos;</span><br><span class="line">                    <span class="keyword">int</span> curMin = Math.min(pos, neg);</span><br><span class="line">                    <span class="keyword">int</span> childValue = curMin + dp[i + <span class="number">1</span>][index] + <span class="number">1</span>;</span><br><span class="line">                    curValue = Math.min(curValue, childValue);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = curValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-区间运算</title>
      <link href="/2023/05/27/%E7%AE%97%E6%B3%95%EF%BC%9A-%E5%8C%BA%E9%97%B4%E8%BF%90%E7%AE%97/"/>
      <url>/2023/05/27/%E7%AE%97%E6%B3%95%EF%BC%9A-%E5%8C%BA%E9%97%B4%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="L253"><a href="#L253" class="headerlink" title="L253"></a>L253</h2><p><img src="https://shain001blog.oss-ap-southeast-2.aliyuncs.com/blogimage-20230527223136668.png" alt="image-20230527223136668"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; flat = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将各个区间扁平化到一个坐标轴中， 即投影到坐标轴上。</span></span><br><span class="line">    <span class="comment">// 当各个点投应到x轴上以后， 接下来需要做的， 只需判断每个点，是start还是end， 如果是start就+1， end就-1</span></span><br><span class="line">    <span class="comment">// 那么不妨直接通过以下结构， 将start的点赋值+1， end的点赋值-1。</span></span><br><span class="line">    <span class="comment">// 注意， 此时for循环以后， 我们已经把所有的点投影到了坐标轴上。</span></span><br><span class="line">    <span class="comment">// 但是为了让代码能够&quot;从左到右遍历坐标轴， 我们需对List进行排序&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] interval: intervals)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] start = &#123;interval[<span class="number">0</span>], <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] end = &#123;interval[<span class="number">1</span>], -<span class="number">1</span>&#125;;</span><br><span class="line">        flat.add(start);</span><br><span class="line">        flat.add(end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序时， 仅对start时间进行升序排列即可保证遍历的顺序为 s1, s2,s3,E2, s4, E3... （见图）</span></span><br><span class="line">    <span class="comment">// 但需注意， 在 s4=e1这种情况时， 要保证line 41 先进行-1操作， 否则会错误的多算一间会议室， 因为一个会议结束的同时另一个会议同时开始的话， 可以使用同一间屋子</span></span><br><span class="line">    <span class="comment">// 所以在两个点的值相等（o[0]）时， 要将 结束的那个点 （即o[1]=-1）排在前面，保证运算顺序。</span></span><br><span class="line">    flat.sort((o1, o2) -&gt; o1[<span class="number">0</span>] == o2[<span class="number">0</span>]? o1[<span class="number">1</span>]-o2[<span class="number">1</span>]: o1[<span class="number">0</span>]-o2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!flat.isEmpty()) &#123;</span><br><span class="line">        count += flat.remove(<span class="number">0</span>)[<span class="number">1</span>];</span><br><span class="line">        result = Math.max(count, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>EffectiveJava-Singleton Using Enum</title>
      <link href="/2022/12/18/EffectiveJava-Singleton/"/>
      <url>/2022/12/18/EffectiveJava-Singleton/</url>
      
        <content type="html"><![CDATA[<h2 id="Two-ways-of-Implement-Singleton-using-Private-Constructor-and-their-drwabacks"><a href="#Two-ways-of-Implement-Singleton-using-Private-Constructor-and-their-drwabacks" class="headerlink" title="Two ways of Implement Singleton using Private Constructor and their drwabacks"></a>Two ways of Implement Singleton using Private Constructor and their drwabacks</h2><h4 id="Method-A-Simply-make-a-static-field-to-hold-the-instance-initiating-it-when-the-class-is-loaded"><a href="#Method-A-Simply-make-a-static-field-to-hold-the-instance-initiating-it-when-the-class-is-loaded" class="headerlink" title="Method A: Simply make a static field to hold the instance, initiating it when the class is loaded"></a>Method A: Simply make a static field to hold the instance, initiating it when the class is loaded</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFieldSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticFieldSingleton SINGLETON_INSTANCE = <span class="keyword">new</span> StaticFieldSingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticFieldSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method-B-Static-Factory-Method"><a href="#Method-B-Static-Factory-Method" class="headerlink" title="Method B: Static Factory Method"></a>Method B: Static Factory Method</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StaticFactorySingleton SINGLETON;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">StaticFactorySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If not using Lazy mode, just simple initiate the field when the class is loaded, and make it as final.</span></span><br><span class="line"><span class="comment">// one draw back of using lazy mode is that the static field cannot be final, which makes a drawback that</span></span><br><span class="line"><span class="comment">// attackers can use reflection to change the SINGLETON field to null, in that case, you would not be able to</span></span><br><span class="line"><span class="comment">// prevent creating multiple instances by checking if the SINGELTON is null before creating it.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticFactorySingleton <span class="title">getInstanceLazyMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SINGLETON == <span class="keyword">null</span>? <span class="keyword">new</span> StaticFactorySingleton(): SINGLETON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DrawBack"><a href="#DrawBack" class="headerlink" title="DrawBack"></a>DrawBack</h4><p><em><strong>When doing serialization the singleton breaks.</strong></em></p><p>Since when the class wants to do the serialization, it would have to inherent Serialization interface, then,  the deserialization process would create a new object, no matter the constructor is private or public, since the constructor is called by the class itself.</p><p>To sovle it, can add a readSolve() method, so that the code would look like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFactorySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StaticFactorySingleton SINGLETON;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticFactorySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If not using Lazy mode, just simple initiate the field when the class is loaded, and make it as final.</span></span><br><span class="line">    <span class="comment">// one draw back of using lazy mode is that the static field cannot be final, which makes a drawback that</span></span><br><span class="line">    <span class="comment">// attackers can use reflection to change the SINGLETON field to null, in that case, you would not be able to</span></span><br><span class="line">    <span class="comment">// prevent creating multiple instances by checking if the SINGELTON is null before creating it.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticFactorySingleton <span class="title">getInstanceLazyMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLETON == <span class="keyword">null</span>? <span class="keyword">new</span> StaticFactorySingleton(): SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Serial</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>Using using reflection the singleton breaks.</strong></em></p><p>When doing the reflection, you can create the instance no matter the constructor is private or public. So to prevent this, within the scope of not using Enum, you can probably:</p><ol><li><p>Check if the instance is created every time when the constructor is called, like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFactorySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StaticFactorySingleton SINGLETON;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticFactorySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SINGLETON != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalCallerException(<span class="string">&quot;Instance already initiated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If not using Lazy mode, just simple initiate the field when the class is loaded, and make it as final.</span></span><br><span class="line">    <span class="comment">// one draw back of using lazy mode is that the static field cannot be final, which makes a drawback that</span></span><br><span class="line">    <span class="comment">// attackers can use reflection to change the SINGLETON field to null, in that case, you would not be able to</span></span><br><span class="line">    <span class="comment">// prevent creating multiple instances by checking if the SINGELTON is null before creating it.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticFactorySingleton <span class="title">getInstanceLazyMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLETON == <span class="keyword">null</span>? <span class="keyword">new</span> StaticFactorySingleton(): SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Serial</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>However, above code still has problem, what if the hacker use reflection to modify the <code>SINGLETON</code> from non-null to null value?</p><p>In this case, we can specify <code>SINGLETON</code> as final, so that the reflection won’t be able to change it value. However, this gives another drawback that you won’t be able to use <code>static factory method</code> to achieve the singleton.</p></li></ol><h2 id="Using-Enum-to-implement-Singleton"><a href="#Using-Enum-to-implement-Singleton" class="headerlink" title="Using Enum to implement Singleton"></a>Using Enum to implement Singleton</h2><p>Enum in Java is natually inherent Serializable, which means it won’t need to explicitly implement the Serialiable Interface, and there is no problem of breaking the singleton when doing serialization.</p><p>Secondly, Enum’s instance would only be initiated only once and users can not touch it since <code>**JVM handles the creation and invocation of enum constructors internally**</code>. </p><p>Thus, all the above problems sovled.</p><h4 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use"></a>How to use</h4><p>Just create a Enum like a normal class, then get the instance like below.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    SingletonEnum() &#123;</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add any public/private methods you want.</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEnumSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingletonEnum singleton = SingletonEnum.INSTANCE;</span><br><span class="line">        singleton.printVal();</span><br><span class="line">        singleton.val = <span class="number">9</span>;</span><br><span class="line">        singleton.printVal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
          <category> Effective Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Singleton </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Java - StaticBuilder &amp; Builder Pattern</title>
      <link href="/2022/12/17/EffectiveJava-staticBuilder/"/>
      <url>/2022/12/17/EffectiveJava-staticBuilder/</url>
      
        <content type="html"><![CDATA[<h1 id="Static-Factory-Method"><a href="#Static-Factory-Method" class="headerlink" title="Static Factory Method"></a>Static Factory Method</h1><h2 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h2><h4 id="Can-define-names-so-that-the-code-is-easy-to-read"><a href="#Can-define-names-so-that-the-code-is-easy-to-read" class="headerlink" title="Can define names, so that the code is easy to read:"></a>Can define names, so that the code is easy to read:</h4><p>Useful when there are multiple constructors. The nature of Java can only differentiate the constructors by parameters.</p><h4 id="Can-avoid-creating-new-instance-every-time"><a href="#Can-avoid-creating-new-instance-every-time" class="headerlink" title="Can avoid creating new instance every time:"></a>Can avoid creating new instance every time:</h4><p>You can control the instance being returned, simliar to the Factory Design Pattern (However note that the static method constructor is not same as the design parttern).</p><p>Useful when:</p><ul><li>immutable classes wants to use preconstructed instances.</li><li>there is no need to create new instances every time, instead you want to return the cached instance. For example the JWT token.</li><li>When you want to ensure there is only one same instance exist at the same time. For example you only want one Country(name = AUS).</li></ul><p>Ps: classes that do like this which have a control of the instances is called <em><strong>instance-controlled</strong></em></p><h4 id="Can-return-subtype-of-the-return-type-gt-make-it-useful-for-interface-based-frameworks"><a href="#Can-return-subtype-of-the-return-type-gt-make-it-useful-for-interface-based-frameworks" class="headerlink" title="Can return subtype of the return type -&gt; make it useful for interface-based frameworks."></a>Can return subtype of the return type -&gt; make it useful for interface-based frameworks.</h4><p>This allows you to:</p><ul><li><em><strong>choose which type of classes are being returned; at the same time, the implementation of the classes are hidden from the user</strong>.</em> E.g., You have a interface that returns type A which is inherented by several calsseses (b, c, d). Then you can choose which child of A is returned for specific scenarios. For example in scenario 1 you want to give b to the user, in sc2 you want to give c. At the same time, since this logic of choosing b, c, d is hidden from the user, so you can change the logic of choosing b, c, d in the future without affecting user’s code.</li><li><em><strong>return an object without making its class be public.</strong></em></li><li>help users avoid reading the additional class documents since they can only refer to the interface.</li></ul><h4 id="The-class-of-the-returned-object-need-not-exist-when-the-class-containing-the-method-is-written"><a href="#The-class-of-the-returned-object-need-not-exist-when-the-class-containing-the-method-is-written" class="headerlink" title="The class of the returned object need not exist when the class containing the method is written."></a>The class of the returned object need not exist when the class containing the method is written.</h4><p>I DONT UNDERSTAND.</p><p>TODO: sample is JDBC. So read the source code to find out.</p><h2 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages:"></a>Disadvantages:</h2><ul><li>Cannot be subclassed if there is only static factory method but no constructors.</li></ul><h1 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h1><h3 id="Advantage"><a href="#Advantage" class="headerlink" title="Advantage"></a>Advantage</h3><p>Use when there are mulitple optional fields. </p><p>If not using builder in this scenario, you would have to either create lots of constructors, or set the values by using setters.</p><p>Both alternative ways are not good:</p><ul><li>For the multiple constructors: Non readable, and not easy to use.</li><li>Using setter: <ul><li>You would have to make the process of constructing a instance be multi-stpes, in other words, not atomic.</li><li>This makes it’s impossible in nature to make a class immutable.</li></ul></li></ul><p>Also, the builder is suited to hierarchies (TODO: do a demo using Generics for Builder).</p><h3 id="Disadvantage"><a href="#Disadvantage" class="headerlink" title="Disadvantage"></a>Disadvantage</h3><p><strong>The Builder pattern is more verbose than the telescoping constructor pattern,so it should be used only if there are enough parameters to make itworthwhile</strong>, say four or more. </p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
          <category> Effective Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Static Builder </tag>
            
            <tag> Builder Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-位运算</title>
      <link href="/2022/02/19/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%89%8B-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2022/02/19/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%89%8B-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Overall"><a href="#Overall" class="headerlink" title="Overall"></a>Overall</h1><p>位运算， 无非： 与， 或， 非， 左移， 右移， 异或。 </p><p>目前接触到位运算的思路主要两种：</p><ul><li>利用异或，找出重复元素：<ul><li>leetcode 136. 只出现一次的数字</li></ul></li><li>利用 左移+与或， 达到用 bit 形成 bool数组， 也即 Redis中的bitmap的形式：<ul><li>leetcode 面试题 01.01 判断无重复字符的字符串</li></ul></li><li>信息论 （略）：<ul><li>老鼠试毒</li></ul></li></ul><p>关于异或， 其记忆的点为： 异或结果与顺序无关。</p><p>关于 左移+与或  这种类型， 只需记忆 bitmap即可， 当一个问题， 需要使用 数组记录一 二元变量的值时， 可以考虑使用 bitmap 替代 Bool[]。</p><p>而bitmap的使用关键， 即是理解， 要 update bitmap中的一位， 则需 将 bitmap 与一 tempBit 进行 或 运算。 读， 则进行 与 运算。 其中 tempBit是一个只包含一个 ‘1’ 的二进制数字。 1 所在的 索引， 即要 读/写 的 bitmap中的对应位索引。</p><p>同时， 字符转数字， 则可通过ASC码实现。 一个字符， 直接进行 左移/右移， 输出的就是数字。 如果需要标的， 则可通过 ”字符-a“ 实现锚定。</p><h2 id="Sample-Question"><a href="#Sample-Question" class="headerlink" title="Sample Question"></a>Sample Question</h2><h4 id="leetcode-136"><a href="#leetcode-136" class="headerlink" title="leetcode 136"></a>leetcode 136</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You must implement a solution with a linear runtime complexity and use only constant extra space.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">输入一组数字， 每个元素都重复一次， 只有 一个元素是单独出现的， 没有重复， 找出这个单独的元素</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">使用异或：</span></span><br><span class="line"><span class="string">异或的特点： 相同为0， 不同为1， “并且异或的顺序不影响结果” 即 A ^ B ^ A ^ B ^ C = A ^ A ^ B ^ B ^ C..</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">nums</span>):</span></span><br><span class="line">    to_return = <span class="number">0</span> <span class="comment"># 之所以初始化为0， 因为 如果 0 与 01010110 异或的话， 原值不变, e.g. 0 ^ 34 = 34</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        to_return = to_return ^ nums[i]</span><br><span class="line">    <span class="keyword">return</span> to_return</span><br></pre></td></tr></table></figure><h4 id="leetcode-面试题01-01"><a href="#leetcode-面试题01-01" class="headerlink" title="leetcode 面试题01.01"></a>leetcode 面试题01.01</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无重复字符的字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 利用bit运算解决 --&gt; 即， 利用 Redis中的bitmap的思路， 形成一个二进制数， 而这个二进制数即相当于一个bool数组。</span></span><br><span class="line"><span class="comment"> * 为什么是bool数组？ 因为 每一位上不是0就是1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 那么接下来， 即如何实现的问题：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 将字符转换为数字 --&gt; ASC码。</span></span><br><span class="line"><span class="comment"> * 2. 如何将 转换后的数字， 映射到 二进制数字中的一位？ 即， 转换后的数字相当于一个索引， 如何利用这个索引， 读/写 二进制中的某一位？</span></span><br><span class="line"><span class="comment"> *    即， 如何将 1001 改为 1000？ 同时， 如何读取到 1001中的 第2 位是0还是1？</span></span><br><span class="line"><span class="comment"> *    --&gt;</span></span><br><span class="line"><span class="comment"> *    通过 与， 或运算。 与即是 读， 或等 便是 写。</span></span><br><span class="line"><span class="comment"> *    以 1001 为例， 要判断 1001 的低处第2位是不是1， 则可用 0010 跟 1001 做 and， 则结果为 1 则代表 第二位为1， 反之为0.</span></span><br><span class="line"><span class="comment"> *    那么， 要将 1001 的低处低2位改为1， 则， 使 1001 |= 0010 即可。 因为 0|0 为0， 0|1 为1， 用0做或， 不会改变原值. 而1 或 任何数</span></span><br><span class="line"><span class="comment"> *    均为1， 所以能达到更改某一个位的值的作用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 至此， 仅剩最后一个步骤， 即如何将字符转换为一个二进制数？</span></span><br><span class="line"><span class="comment"> * --&gt; 左移 + ASC码。</span></span><br><span class="line"><span class="comment"> *     3.1 首先， 要的到 1000， 则只需 将 0001， 也即1， 左移3 位即可。</span></span><br><span class="line"><span class="comment"> *     3.2 每个字符， 与 ‘a’ 相减， 则能得到一个唯一数 x， 也即， 1 左移 x位， 就能得到该字符对应的唯一 二进制数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 最后， 针对此题的context， 字符的数量， 也即字符的种类， 最多有128个， 也即需要 128 位 这么长的二进制数， 也即， 两个 long型变量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueLCCI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(checkUnique(&quot;123&quot;));</span></span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">        System.out.println(c&lt;&lt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkUnique</span><span class="params">(String target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// high 64 bits and low 64bits</span></span><br><span class="line">        <span class="keyword">long</span> high = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> low = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Character c : target.toCharArray())&#123;</span><br><span class="line">            <span class="comment">// check use high bits or low bits</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="number">64</span>)&#123;</span><br><span class="line">                <span class="keyword">long</span> toBit = <span class="number">1l</span> &lt;&lt; (c-<span class="number">64</span>);</span><br><span class="line">                <span class="keyword">if</span> ((high &amp; toBit) != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// if not return, then update high bits to record a character</span></span><br><span class="line">                high |= toBit;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">long</span> toBit = <span class="number">1l</span> &lt;&lt; c;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((low &amp; toBit) != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                low |= toBit;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> bitmap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bitmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-动态规划</title>
      <link href="/2022/01/23/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%89%8B-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/01/23/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%89%8B-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划标志："><a href="#动态规划标志：" class="headerlink" title="动态规划标志："></a>动态规划标志：</h1><ul><li>求最优解， 但是又不要求具体路径。</li></ul><h2 id="二维dp的优化"><a href="#二维dp的优化" class="headerlink" title="二维dp的优化"></a>二维dp的优化</h2><p>核心： 滚动数组</p><p>直接看例子即可， 不好语言表述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_path</span>(<span class="params">grid</span>):</span></span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid))]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(grid)):</span><br><span class="line">        dp[j][<span class="number">0</span>] = dp[j - <span class="number">1</span>][<span class="number">0</span>] + grid[j][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(grid)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">            dp[i][j] = grid[i][j] + <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_path_loop</span>(<span class="params">grid: <span class="type">List</span>[<span class="type">List</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Point is that, when optimize space complexity for 2d dp array, we can only optimize 2d to 1d array.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    注意观察 3 Mention commented in the code</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    优化原理：</span></span><br><span class="line"><span class="string">    一句话概括：  dp变成了滚动数组。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    首先， 对于二维dp中每一个格子i, j的计算， 我们需要的只有三个数： 1. up， 2. left， 3. grid中的i,j 的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    那么， 只要优化后的一维数组 能够记录到 1 &amp; 2 ， 则可计算 出 i， j的值。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    只用一维数组怎么表示i，j的值？</span></span><br><span class="line"><span class="string">    第一层循环的for row in rows， 就相当于表示了i， 而j， 则是第二层循环的col表示。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    怎么用一维dp记录的 上下两个维度的数？</span></span><br><span class="line"><span class="string">    滚动数组， 当遍历到dp_oned[col]时， 当前的dp_oned[col] 的值， 还是记录着 dp[i-1][j]的值， 但是dp_oned[col-1]已经被更新成了dp[i][j-1]了。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    那二维dp中的第一行怎么办？ </span></span><br><span class="line"><span class="string">    初始 dp_oned 为 grid[0]</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    那最上面一行， 最左侧一列的数怎么办？ 这一行/一列的数据， 没有上面/左侧的格子。 </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    看Mention 2</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    具体讲：</span></span><br><span class="line"><span class="string">    首先， 优化后的一维 dp， 相当于先记录了 原2维dp的第一行所有数，然后变成 第二行， ....</span></span><br><span class="line"><span class="string">    其次， 对于优化后的一维dp， 其每一个元素都对应着原dp中的一个i, j， 再dp[j]被更新之前， 它还保存着 原dp[i-1, j]的值。 同时， 由于是从左到右不停的   遍历dp。</span></span><br><span class="line"><span class="string">    这意味着 当 遍历到 dp[j]的时候， dp[j] 左边的格子 dp[j-1] 已经被更新， 即意味着其记录的值， 已经是原二维dp中的 i-1,j 这个格子的值了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    说话不好理解， 看例子：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    懒的画。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    只要记住， 对于每一次循环过程中， 再 col 变成 len(cols) - 1之前， 一维的dp中 既有 二维dp中 第i 行的值， 也有第 i-1 行的值。</span></span><br><span class="line"><span class="string">    而当一次 cols for结束， row从i 变为 i-1时， dp表示的行， 就从二维dp中的第i行变为第i+1行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param grid:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cols = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    rows = <span class="built_in">len</span>(grid)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Mention 1</span></span><br><span class="line">    dp = grid[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Mention 2</span></span><br><span class="line">            left_max = <span class="number">0</span> <span class="keyword">if</span> col == <span class="number">0</span> <span class="keyword">else</span> dp[col-<span class="number">1</span>]</span><br><span class="line">            up_max = <span class="number">0</span> <span class="keyword">if</span> row == <span class="number">0</span> <span class="keyword">else</span> dp[col]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Mention 3</span></span><br><span class="line">            dp[col] = grid[row][col] + <span class="built_in">max</span>(left_max, up_max)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>Original by Shain at Mel, Australia</p><p>Last Updated: 2022/1/23</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-数组/字符串</title>
      <link href="/2022/01/20/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%89%8B-%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/01/20/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%89%8B-%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="数组问题的时间复杂度优化"><a href="#数组问题的时间复杂度优化" class="headerlink" title="数组问题的时间复杂度优化"></a>数组问题的时间复杂度优化</h1><h2 id="overalll"><a href="#overalll" class="headerlink" title="overalll"></a>overalll</h2><p>单纯的与数组相关的问题（包括字符串）， 题目本身通常不难， 难点在与如何优化时间复杂度。</p><p>例如：</p><ul><li>offer 39-41 ：<ul><li>找到数组中数量大于一半的数字</li><li>找到数组中第k小的k个数</li><li>找到流数据的中位数</li></ul></li></ul><p>这些问题， 使用单纯的暴力排序均可解答， 但时间复杂度较高。</p><p>可以使用的优化方法：</p><ul><li><p>Partition：</p><ul><li><p>如果问题问的是 第k个数怎么怎么样， 例如数组中第k大的数，或者最小的k个数， 那么可以使用Partition求解。</p><p>因为通过快排的partition方法， 可以O(n) 的找到第k小的数字， 当然这也包扩小于第k小数字的所有数字。</p></li></ul></li><li><p>二分：</p><ul><li>如果是找 两个数组中第k小的数字， 那么除了merge两个数组以外， 可以使用二分的思想， 当然使用二分的前提是两个数组均是排序的。</li></ul></li><li><p>数据结构的利用：</p><ul><li>priority queue： 最小堆， 最大堆</li><li>AVL Tree</li><li>链表</li></ul><p>offer41以及offer40.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> String&amp;Array Optimization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stringArray optimization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud configures Hystrix using Feign Record</title>
      <link href="/2022/01/07/Spring-Cloud-configures-Hystrix-using-Feign-Record/"/>
      <url>/2022/01/07/Spring-Cloud-configures-Hystrix-using-Feign-Record/</url>
      
        <content type="html"><![CDATA[<h2 id="fallback-vs-fallbackFactory"><a href="#fallback-vs-fallbackFactory" class="headerlink" title="fallback vs fallbackFactory"></a>fallback vs fallbackFactory</h2><p>fallback 方式无法获取异常内容， 只能做降级。</p><p>fallbackFactory 可以获取异常内容。</p><h1 id="fallbackFactory-使用方式"><a href="#fallbackFactory-使用方式" class="headerlink" title="fallbackFactory 使用方式"></a>fallbackFactory 使用方式</h1><ol><li>Maven -&gt; Hystrix</li><li>配置文件修改</li><li>启动类注解@EnableCircuitBreaker开启断路器</li><li>Feign 接口 （接口名假设为Feign， 方便下文描述） 的注解 @FeignClient(……    fallbackFactory = FallBackClass.class)设置fallback =</li><li>创建FallBackClass-&gt; implements FallbackFactory<T> 接口， T值为Feign 接口类名</li><li>创建 InheritanceClass 接口， 继承 Feign接口 Feign。 内容为空即可。 </li><li> 在 FallBackClass中override FallbackFactory的方法， 只有一个 create 方法， 其返回值类型为 Feign， this is why we need to do step5。 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PaymentConsumerFeign <span class="title">create</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &#123;&#125;中的内容会被替换为 throwable.getMessage() 获取的内容</span></span><br><span class="line">    LOG.error(<span class="string">&quot;ExceptionTest = &#123;&#125;&quot;</span>, throwable.getMessage());</span><br><span class="line">    <span class="comment">// 之所以创建空接口 InheritanceClass， 因为此处直接return new ...即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PaymentConsumerWithFallBackFactory() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">consumePayment</span><span class="params">(String userId, String saleId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Oops, server is busy&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LOG.error(“ExceptionTest = {}”, throwable.getMessage())输出的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExceptionTest = status 500 reading PaymentConsumerFeign#consumePayment(String,String); content:</span><br><span class="line">&#123;&quot;timestamp&quot;:&quot;2022-01-07T06:41:58.885+0000&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;Not Created Yet&quot;,&quot;path&quot;:&quot;/processPayment&quot;&#125;</span><br></pre></td></tr></table></figure><p>Provider中抛出的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (state == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Not Created Yet&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fallback方式的使用"><a href="#fallback方式的使用" class="headerlink" title="fallback方式的使用"></a>fallback方式的使用</h2><p>只需：</p><ol><li> @FeignClinet()中设置为fallback = FallBackClass</li><li>创建FallBackClass， implements Feign接口</li><li>对于每个方法， 写出降级内容即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sale </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project reflection</title>
      <link href="/2022/01/03/project-reflection/"/>
      <url>/2022/01/03/project-reflection/</url>
      
        <content type="html"><![CDATA[<h1 id="Zookeeper伪集群搭建"><a href="#Zookeeper伪集群搭建" class="headerlink" title="Zookeeper伪集群搭建"></a>Zookeeper伪集群搭建</h1><ol><li><p>下载zookeeper</p></li><li><p>解压修改config中的dataDir and dataLogDir</p></li><li><p>复制三份加压安装好后的文件， 方便运行不同server。（若不复制， 则直接创建三份不同的config文件， 运行时指明conf文件）。</p></li><li><p>分别修改三个复制后zookeeper中的config， 修改各自的clientport + dataDir + logDir + server.1 = .. server.2 = …</p></li><li><p>在data文件夹中创建myid， 内容为1，2， 3， … 目的为指明各个server的id</p></li><li><p>分别运行即可</p></li></ol><h1 id="SpringBoot整合zookeeper为注册中心-（跟Eureka一个作用）"><a href="#SpringBoot整合zookeeper为注册中心-（跟Eureka一个作用）" class="headerlink" title="SpringBoot整合zookeeper为注册中心 （跟Eureka一个作用）"></a>SpringBoot整合zookeeper为注册中心 （跟Eureka一个作用）</h1><p>Reflection:</p><ol><li>Eureka vs Zookeeper</li></ol><p>实现：</p><ol><li><p>zookeeper注册中心配置必须在boostrap.yml,  why application.yml不生效？</p></li><li><p>在application.yml中配置service信息</p></li></ol><h1 id="关于支付模块修改订单状态的问题"><a href="#关于支付模块修改订单状态的问题" class="headerlink" title="关于支付模块修改订单状态的问题"></a>关于支付模块修改订单状态的问题</h1><h4 id="Confusion"><a href="#Confusion" class="headerlink" title="Confusion:"></a>Confusion:</h4><p>首先， 该confusion以 用户跳转支付页面与orderGeneration模块 parallel为前提。</p><p>创建订单的模块从MQ接受消息， 然后创建订单， 这个创建订单的处理速度受MQ限制。</p><p>那么会不会有一种情况， 当1000个用户一瞬间抢完商品， 之后1000个用户同时点击“支付完成”， 点击该button会ping到修改订单状态的API。 即， 这1000 个订单可能在 抢购结束后， 立刻， 且同时， 被要求更改订单状态。 但是， 此时1000个订单可能还没有都被创建到数据库。 那么有的用户在点击”支付完成“时可能会返回报错， 即修改订单失败，因为后端无法修改到订单状态（该raw还未被创建）。</p><h4 id="solution"><a href="#solution" class="headerlink" title="solution:"></a>solution:</h4><ol><li> 假设该问题无法解决， 则修改订单失败时返回降级页面， 提示用户等下再支付。 若如此解决， project需添加购物车， 进而有需要分布式Session</li></ol><h4 id="关于Confusion中的状况实际上应该不会发生的猜想："><a href="#关于Confusion中的状况实际上应该不会发生的猜想：" class="headerlink" title="关于Confusion中的状况实际上应该不会发生的猜想："></a>关于Confusion中的状况实际上应该不会发生的猜想：</h4><p>实际业务中， 由于有支付环节， 该环节中需要：</p><p>​    a) 检测安全环境</p><p>​    b) ping支付宝/微信/paypal… 的API</p><p>​    c) 输入密码</p><p>​    d) 支付API处理请求</p><p>这些过程耗时至少10s - 20s。 </p><p>在实际业务中， 用户抢购商品以后 -&gt; 后端开始创建订单, 同时， 另一个支付Model 被parallel的运行， 引导用户付款。 -&gt;付款结束才能点击支付完成， 或者支付完成，在payment model中修改订单状态。 </p><p>由于支付业务耗时长， 所以订单应该一定已经被创建。 </p><p><strong>同时， 为了加快订单创建速度， 保证修改某订单状态时， 订单状态一定要保证完成， 可以增加 order Model的数量， 同时rabbitMQ中多建几个queue， 多个ordermodel 分发处理以加快订单创建速度。</strong></p><h4 id="关于能否通过先在Redis缓存订单来解决该问题："><a href="#关于能否通过先在Redis缓存订单来解决该问题：" class="headerlink" title="关于能否通过先在Redis缓存订单来解决该问题："></a>关于能否通过先在Redis缓存订单来解决该问题：</h4><p>应该不现实， 因为订单数量极大的情况下， redis内存抗不住， 只能增加redis服务器数量， 不值得。因为在秒杀情况下， users大概率可以接受服务降级， 或服务速度减慢。 </p><h3 id="实际上的架构"><a href="#实际上的架构" class="headerlink" title="实际上的架构"></a>实际上的架构</h3><p><img src="E:\BBlog\source_data\images\payment_orderGeneration.png" alt="payment_orderGeneration"></p><h1 id="记录一次RabbitMQ-重复消费-“cannot-ack-nack”-产生的超卖"><a href="#记录一次RabbitMQ-重复消费-“cannot-ack-nack”-产生的超卖" class="headerlink" title="记录一次RabbitMQ 重复消费 “cannot ack/nack” 产生的超卖"></a>记录一次RabbitMQ 重复消费 “cannot ack/nack” 产生的超卖</h1><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>忘记在 RabbitQueue Consumer中， 即 order module 的 application.yml 中配置 RabbitMQ。 进而导致默认使用了自动ACK模式。</p><p>具体原因待研究。</p><h3 id="表象"><a href="#表象" class="headerlink" title="表象"></a>表象</h3><p>懒得截图：</p><p>100个库存， 压测并发100 个请求时， 查询MySQL发现下了199个订单一次， 201个订单一次， flash_sale表跟 order表数据是一致的， 即同时 减少/增加相同的订单量。 但是Redis中库存始终正确， 未出现超卖现象。</p><p>同时order model报错  cannot ack/nack。</p><h2 id="MyBatis-Update-…-引发的报错：-“There-is-no-getter-for-property-named-‘’-in-‘class-java-lang-String"><a href="#MyBatis-Update-…-引发的报错：-“There-is-no-getter-for-property-named-‘’-in-‘class-java-lang-String" class="headerlink" title="MyBatis @Update(…..  ${} )引发的报错： “There is no getter for property named ‘’ in ‘class java.lang.String"></a>MyBatis @Update(…..  ${} )引发的报错： “There is no getter for property named ‘’ in ‘class java.lang.String</h2><p>原因：</p><p>${}  and #{}的使用错误， 修改为 #{}后报错消失， 但是其他接口方法中（@Insert）使用 ${}没有报错， 正常运行。</p><p>待仔细学习MyBatis后解答。</p><h1 id="关于Order-Module中的疑问"><a href="#关于Order-Module中的疑问" class="headerlink" title="关于Order Module中的疑问"></a>关于Order Module中的疑问</h1><h4 id="Current-Version-of-Code"><a href="#Current-Version-of-Code" class="headerlink" title="Current Version of Code:"></a>Current Version of Code:</h4><ol><li>recievge message from MQ</li><li>write order to db</li><li>change stock in db</li><li>return ack to MQ to tell MQ delete the message</li></ol><p>整个Order Module没有任何返回值， 即状态返回。</p><h4 id="Confusion-1"><a href="#Confusion-1" class="headerlink" title="Confusion:"></a>Confusion:</h4><p>测试发现， 数据库操作即使失败， 依然会返回ack删除数据。如何解决?</p><p>同时， write正常工作时， 如果 change stock方法出错， 也是依然返回了ACK。</p><p>是因为加了try catch才没有在方法执行失败时 卡住程序？ 怎么解决？ 不能把ack返回写在finally中， 因为这样就是无论对错消息都删除了。</p><p>目前用的解决方案：</p><p>Service方法中返回值， 即更新数据库的方法的返回值 == 1时才return ACK。 有无更好方法？</p><p>并且实际业务中， Order模块没有任何返回状态的话， 如果出了问题如何发现？</p><h1 id="關於Bloom-Filter"><a href="#關於Bloom-Filter" class="headerlink" title="關於Bloom Filter"></a>關於Bloom Filter</h1><p>zuul中加了bloom filter 解決緩存擊穿問題及過濾非法請求。</p><p>在product scan scheduler中<strong>反復刷新</strong>bloom filter。</p><p>之所以要刷新， 而不是反復添加， 理由如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// rBloomFilter doesn&#x27;t have method to remove a elements, so if do not refresh, then with time increase</span><br><span class="line">// all bits in the bloom filter will be filled out, which means all retrieve will be returned true, the bloom</span><br><span class="line">// filter will lose its meanning.</span><br><span class="line">// so here every time scanning the flash sale DB, we refresh the bloom filter to maintain the precision.</span><br><span class="line">// Although this may cause a problem that during this task is refreshing the bloom filter,</span><br><span class="line">// there might be a short period that bloom filter lacks some elements, so some impossible requests may not be</span><br><span class="line">// filtered by the gateway, the number of such requests should not too much.</span><br><span class="line">// More importantly by now I don&#x27;t see other solutions.</span><br></pre></td></tr></table></figure><h1 id="待看"><a href="#待看" class="headerlink" title="待看"></a>待看</h1><ol><li><p>启动类中@FeignClients注解不加参数就找不到bean</p></li><li><p>细看 Hystrix, Ribbon, Feign</p></li><li><p>Netty</p></li><li><p>细看操作系统 -&gt; NIO， 虚拟内存</p></li><li><p>java异常 classes</p></li><li><p>SpringCloud Gateway VS Zuul</p></li><li><p>Zuul 配置timeout时间， 默认时间多少？ 不配置则得到了</p></li><li><p><strong>RabbitMQ unacked Message caused lots of message blocked:</strong></p><p>​    表象：</p><p>​        OrderGenerate Module中收不到新的订单消息。</p><p>​        RabbitMQ中始终显示一条unacked Message</p><p>​    原因：</p><pre><code>      1. 逻辑错误： 设定 if(updateState and changeState == 1) 才返回ACK， ”但是module刚启动时， 同时更新了多条消息？ **两个state值不为0**，导致没有返回ACK， 更新为 if (xxxx,xxxx != 0) 后不在有ACK “ 8. 2 ordermodel的application.yml中只配置了 web_order的分表， 由于 web_seckill未使用分表， 所以没有配置， 但是报错了 FlashSale_2.web_seckill不存在。</code></pre><p>​    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">com.netflix.zuul.exception.ZuulException: Forwarding error</span><br><span class="line">+</span><br><span class="line">readtimeout 报错；</span><br><span class="line">应该时默认超时时间过短导致</span><br></pre></td></tr></table></figure></li></ol><h1 id="Data-Sharding-and-RW-Splitting-Archetecture"><a href="#Data-Sharding-and-RW-Splitting-Archetecture" class="headerlink" title="Data Sharding and RW Splitting Archetecture"></a>Data Sharding and RW Splitting Archetecture</h1><p><img src="E:\ShianGit\flash_sale\images\MySQL-Archetecture\data_sarding_RWSplitting.jpg" alt="data_sarding_RWSplitting"></p><p>Web_seckill 未做分表/分库。 不知道是否规范， 未做原因在于判断 秒杀商品数量不多， 对于该表访问压力不大 ；</p><p>Specificly,  该项目逻辑为 —-  创建订单的同时扣减库存。 创建订单Module从MQ消费消息， 消费QPS均固定， 并且可控。 Moreover, 秒杀过程中对于库存的查询皆走的Redis， 进一步减小了对该表的访问频率。  MoreMoreover， 对该表的查询，只在product scanning 定时进行， 频率也可控， 且访问量不大， 且Master-Slave的读写分离顺带着给web_seckill库存表也做了读写分离， 又进一步减小数据库压力。   因此判断数据库压力不大， 故未做分表/分库。 </p><p>一句话概括上面内容：</p><p>web_seckill 的访问压力 可控， 并且不大， 所以不作。  不大的原因： 1.  访问QPS由 消费MQ的速度决定，所以”写“ 速度 可控。  2.  读写分离的设定， 又进一步减小了压力。 并且对于web_seckill表的读取， 每xx分钟才由 product scanning scheduler进行一次， 读取频率很低。</p><p>PS:</p><p>web_seckill秒杀库存表应该可以做成broadcast table， 未作。</p><p>Shardingj 配置 –  分库分表Only：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">shardingsphere:</span><br><span class="line">  # 1. Configure DataSource, same as normal datasource configuration</span><br><span class="line">  datasource:</span><br><span class="line">    # Allocate name to different databases</span><br><span class="line">    names: ds1,ds2</span><br><span class="line">    # Configure each databases</span><br><span class="line">    ds1:</span><br><span class="line">      # configure type first -&gt; can use almost any connection pool</span><br><span class="line">      type: com.zaxxer.hikari.HikariDataSource</span><br><span class="line">      driver-class-name: com.p6spy.engine.spy.P6SpyDriver</span><br><span class="line">      # This has to be jdbc-url instead of url, otherwise the system cannot find the url address</span><br><span class="line">      jdbc-url: jdbc:p6spy:mysql://192.168.100.128:3306/FlashSale</span><br><span class="line">      username: root</span><br><span class="line">      password: 1122110</span><br><span class="line">      hikari:</span><br><span class="line">        maximum-pool-size: 30</span><br><span class="line">        minimum-idle: 10</span><br><span class="line">    ds2:</span><br><span class="line">      # configure type first -&gt; can use almost any connection pool</span><br><span class="line">      type: com.zaxxer.hikari.HikariDataSource</span><br><span class="line">      driver-class-name: com.p6spy.engine.spy.P6SpyDriver</span><br><span class="line">      jdbc-url: jdbc:p6spy:mysql://192.168.100.128:3306/FlashSale_2?serverTimezone=GMT%2B10</span><br><span class="line">      username: root</span><br><span class="line">      password: 1122110</span><br><span class="line">      hikari:</span><br><span class="line">        maximum-pool-size: 30</span><br><span class="line">        minimum-idle: 10</span><br><span class="line">  # 2. Configure Table/DB selection strategies</span><br><span class="line">  sharding:</span><br><span class="line">    tables:</span><br><span class="line">      web_order_:</span><br><span class="line">        actual-data-nodes: ds$-&gt;&#123;1..2&#125;.web_order_$-&gt;&#123;1..2&#125;</span><br><span class="line">        table-strategy:</span><br><span class="line">          inline:</span><br><span class="line">            sharding-column: id</span><br><span class="line">            algorithm-expression: web_order_$-&gt;&#123;id % 2 +1&#125;</span><br><span class="line">        database-strategy:</span><br><span class="line">          inline:</span><br><span class="line">            sharding-column: saleId</span><br><span class="line">            algorithm-expression: ds$-&gt;&#123;saleId % 2 +1&#125;</span><br><span class="line">      web_seckill:</span><br><span class="line">        actual-data-nodes: ds1.web_seckill</span><br><span class="line">  props:</span><br><span class="line">    sql:</span><br><span class="line">      show: true</span><br></pre></td></tr></table></figure><p>Shardingj 配置 –  分库分表  + Read Write Split：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8000</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true</span><br><span class="line">  application:</span><br><span class="line">    name: orderGenerator</span><br><span class="line"># updated to ShardingSephere at 2022/1/11</span><br><span class="line">#  datasource:</span><br><span class="line">#    driver-class-name: com.p6spy.engine.spy.P6SpyDriver</span><br><span class="line">#    url: jdbc:p6spy:mysql://192.168.100.128:3306/FlashSale</span><br><span class="line">#    username: root</span><br><span class="line">#    password: 1122110</span><br><span class="line">#    hikari:</span><br><span class="line">#      maximum-pool-size: 30</span><br><span class="line">#      minimum-idle: 10</span><br><span class="line">  shardingsphere:</span><br><span class="line">    # 1. Configure DataSource, same as normal datasource configuration</span><br><span class="line">    datasource:</span><br><span class="line">      # Allocate name to different databases</span><br><span class="line">      # Dont forgot to list any name here, other wise got error:</span><br><span class="line">      # java.lang.IllegalStateException: Missing the data source name: &#x27;ds1_slave&#x27;</span><br><span class="line">      #at com.google.common.base.Preconditions.checkState(Preconditions.java:197)</span><br><span class="line">      names: ds1,ds1slave,ds2,ds2slave</span><br><span class="line">      # Configure each databases</span><br><span class="line">      ds1:</span><br><span class="line">        # configure type first -&gt; can use almost any connection pool</span><br><span class="line">        type: com.zaxxer.hikari.HikariDataSource</span><br><span class="line">        driver-class-name: com.p6spy.engine.spy.P6SpyDriver</span><br><span class="line">        # This has to be jdbc-url instead of url, otherwise the system cannot find the url address</span><br><span class="line">        jdbc-url: jdbc:p6spy:mysql://192.168.100.128:3306/FlashSale?serverTimezone=GMT%2B10</span><br><span class="line">        username: root</span><br><span class="line">        password: 1122110</span><br><span class="line">        hikari:</span><br><span class="line">          maximum-pool-size: 30</span><br><span class="line">          minimum-idle: 10</span><br><span class="line">      # slave for ds1</span><br><span class="line">      ds1slave:</span><br><span class="line">        # configure type first -&gt; can use almost any connection pool</span><br><span class="line">        type: com.zaxxer.hikari.HikariDataSource</span><br><span class="line">        driver-class-name: com.p6spy.engine.spy.P6SpyDriver</span><br><span class="line">        # This has to be jdbc-url instead of url, otherwise the system cannot find the url address</span><br><span class="line">        jdbc-url: jdbc:p6spy:mysql://127.0.0.1:3306/FlashSale?serverTimezone=GMT%2B10</span><br><span class="line">        username: root</span><br><span class="line">        password: 1122110</span><br><span class="line">        hikari:</span><br><span class="line">          maximum-pool-size: 30</span><br><span class="line">          minimum-idle: 10</span><br><span class="line">      ds2:</span><br><span class="line">        # configure type first -&gt; can use almost any connection pool</span><br><span class="line">        type: com.zaxxer.hikari.HikariDataSource</span><br><span class="line">        driver-class-name: com.p6spy.engine.spy.P6SpyDriver</span><br><span class="line">        jdbc-url: jdbc:p6spy:mysql://192.168.100.128:3306/FlashSale_2?serverTimezone=GMT%2B10</span><br><span class="line">        username: root</span><br><span class="line">        password: 1122110</span><br><span class="line">        hikari:</span><br><span class="line">          maximum-pool-size: 30</span><br><span class="line">          minimum-idle: 10</span><br><span class="line">      ds2slave:</span><br><span class="line">        # configure type first -&gt; can use almost any connection pool</span><br><span class="line">        type: com.zaxxer.hikari.HikariDataSource</span><br><span class="line">        driver-class-name: com.p6spy.engine.spy.P6SpyDriver</span><br><span class="line">        jdbc-url: jdbc:p6spy:mysql://127.0.0.1:3306/FlashSale_2?serverTimezone=GMT%2B10</span><br><span class="line">        username: root</span><br><span class="line">        password: 1122110</span><br><span class="line">        hikari:</span><br><span class="line">          maximum-pool-size: 30</span><br><span class="line">          minimum-idle: 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # Configure Table selection strategies</span><br><span class="line">    sharding:</span><br><span class="line">      defaultDataSourceName: ds1</span><br><span class="line">      tables:</span><br><span class="line">        web_order_:</span><br><span class="line">          actual-data-nodes: ms_ds$-&gt;&#123;1..2&#125;.web_order_$-&gt;&#123;1..2&#125;</span><br><span class="line">          table-strategy:</span><br><span class="line">            inline:</span><br><span class="line">              sharding-column: id</span><br><span class="line">              algorithm-expression: web_order_$-&gt;&#123;id % 2 +1&#125;</span><br><span class="line">          database-strategy:</span><br><span class="line">            inline:</span><br><span class="line">              sharding-column: saleId</span><br><span class="line">              algorithm-expression: ms_ds$-&gt;&#123;saleId % 2 +1&#125;</span><br><span class="line">        web_seckill:</span><br><span class="line">          actual-data-nodes: ms_ds1.web_seckill</span><br><span class="line">      master-slave-rules:</span><br><span class="line">        ms_ds1:</span><br><span class="line">          masterDataSourceName: ds1</span><br><span class="line">          slaveDataSourceNames:</span><br><span class="line">            - ds1slave</span><br><span class="line">        ms_ds2:</span><br><span class="line">          masterDataSourceName: ds2</span><br><span class="line">          slaveDataSourceNames:</span><br><span class="line">            - ds2slave</span><br><span class="line">    props:</span><br><span class="line">      sql:</span><br><span class="line">        show: true</span><br><span class="line">  devtools:</span><br><span class="line">    restart:</span><br><span class="line">      enabled: true</span><br><span class="line">      additional-paths: src/main/java</span><br><span class="line">  rabbitmq: # rabbitmq configuration</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    virtual-host: /</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line">    connection-timeout: 5000</span><br><span class="line">    listener:</span><br><span class="line">      simple:</span><br><span class="line">        acknowledge-mode: manual</span><br><span class="line">        prefetch: 1</span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml</span><br><span class="line">  type-aliases-package: com.java.pojo</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Problems-Reflection："><a href="#Problems-Reflection：" class="headerlink" title="Problems Reflection："></a><strong>Problems Reflection：</strong></h3><ol><li><p>配置数据源时， 官网文档配置方式为 url: xxxxxx； 但项目中报错， 修改为 jdbc-url: xxx时 解决。  不确定原因， 可能与 sharding 版本及 连接池 选取有关。</p></li><li><p>sharding pom使用 4.0.0 RC 版本时， 报错 data tuncate error:  Now()…  。  NOW() 不可用。 已经确定是该版本bug， 更换 4.1.1 版本后解决</p></li><li><p>RabbitMQ 导致的：</p><ol><li><p>消息阻塞， 无法创建订单。</p><p>a. 逻辑错误导致返回ACK的代码未被执行</p><p>b. 忘了配置DB的选取策略， 导致更新web_seckill的 query始终返回0</p><p>两个错误导致ACK未被正确返回， 导致MQ中始终有unacked消息， 由于<strong>rabbitMQ的机制（待看）</strong>， 导致消息被阻塞。</p></li><li><p>发送一条request， 创建多条订单。</p><p>a. 不确定原因， 应该也与 rabbitMQ机制导致的 unack时重试机制产生， 1.a/1.b修复后没有再发生</p></li><li><p>与上两条错误相关：  再unack消息存在时， 每当重启module后有时可创建到消息， 但都是之前发送的积压订单。 新启动以后发送的请求未被创建到订单。 并且不管发送多少条都没有被创建， 但是再下次重启时， 又创建到了之前发送的请求。</p><p>应该也是unack的阻塞导致的， 也与 重试机制等有关。</p></li></ol></li><li><p>配置读写分离时报错：</p><p>java.lang.IllegalStateException: Missing the data source name: ‘ds1_slave’</p><p>at com.google.common.base.Preconditions.checkState(Preconditions.java:197)</p><p>原因：</p><p>datasources.names中忘了加两个slave的名字， 添加后解决。</p></li><li><p>修改 sharding column 时报错：</p><p>Cause: java.lang.NullPointerException: Cannot invoke method mod() on null object</p><p>原因： 修改了algorithm-expression: xxx 但是忘了修改对应的 sharding-column: xx</p></li><li><p>sharding-column的修改：</p><ol><li><p>原配置：</p><p>sharding-column分别为 order_No and saleId， 对应分表及分库策略</p><p>问题：</p><p>只考虑创建订单的话，用这两个column选用表和库没问题， 但是由于payment module中使用 userId + saleId 更新数据， column的使用不同， <strong>是否有可能retrieve不到数据？</strong>因为 写订单时， orderno 和 saleid决定了去4个表中的哪个表（2库， 每个库2个表）， 那么retrieve数据时， 用orderno+saleid检索，或者只用其中一个检索就没问题， 因为一定能route到数据所在的表,  但是 若用 userId+saleId的话， <strong>是否有可能根据 saleId 选定了库， 但是因为这个query中只有saleId, 没有orderno， 所以是否可能数据所在的表不在这个库中？  就算sharding能自动解决这个问题的话， 应该也需要检测两个库中的表1， 或一个库中的表1及表2， 应该会拖慢并发量。</strong> 因此改成根据saleId + userId选取库和表。</p></li><li><p>Alternative Solution:</p><p>Solution 1:</p><p>仍然用 orderno + saleid 做分库分表。然后再payment module中根据orderno  retrive row修改状态。 但是问题是这样payment接受的http参数就必须是orderno, 也就意味着orderno必须在用户秒杀成功后直接从deduct redis中返回。 然而问题在于目前 orderno在ordergenerate model中生成， 其从MQ接受消息， 与deduct redis异步执行， 所以没办法从ordergenerate model返回orderno 到deduct redis然后再从deduct redis返回给用户。 （该问题应该无解， 因为MQ异步）</p><p>要解决该问题， 就得让order no在deduct redis这个秒杀module中生成， 但是这样一来该module就在秒杀过程中干了别的事， 尽管生成订单号业务不复杂， 但是应该还是会拖慢并发量。</p><p>Solution 2:</p><p>只用一个column做sharding-column， 即库/表的选取都是对同一个column取模。 </p><p>不确定这样是否可行， 没试（理论上觉得可行）。 同时也不确定这样是否有任何缺点。</p></li></ol></li></ol><p>**RW Splitting Validation ** （测试于修改sharding column之前）</p><p><img src="E:\ShianGit\flash_sale\images\MySQL-Archetecture\MS_Write_Validation.PNG" alt="MS_Write_Validation"></p><p><img src="E:\ShianGit\flash_sale\images\MySQL-Archetecture\MS_Select_Validation.PNG" alt="MS_Select_Validation"></p><p>分库分表验证未截图， 但对于saleId=2时， 做orderNo的测试， 分表的选择没有问题。</p><p>由于redis中没添加 奇数的saleId， 所以未测分库的选取， 但应该没有问题。</p><h1 id="Redis-Master-slave-Sentinel-的报错（大坑）"><a href="#Redis-Master-slave-Sentinel-的报错（大坑）" class="headerlink" title="Redis Master/slave + Sentinel 的报错（大坑）"></a>Redis Master/slave + Sentinel 的报错（大坑）</h1><h3 id="配置sentinel时-redisson及redis读到的ip始终是Localhost，-而不是配置文件中设置的VM-IP。-进而导致："><a href="#配置sentinel时-redisson及redis读到的ip始终是Localhost，-而不是配置文件中设置的VM-IP。-进而导致：" class="headerlink" title="配置sentinel时,  redisson及redis读到的ip始终是Localhost， 而不是配置文件中设置的VM IP。 进而导致："></a>配置sentinel时,  redisson及redis读到的ip始终是Localhost， 而不是配置文件中设置的VM IP。 进而导致：</h3><h4 id="Errors"><a href="#Errors" class="headerlink" title="Errors:"></a>Errors:</h4><ul><li>Cannot connect to server  –&gt; 原因1. Sentinel问题</li><li>Sentinel Sentinels return empty sets  –&gt; 原因1</li><li>Cannot connect to 127.0.0.1：Master/Slave’s port–&gt; 原因2</li></ul><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><ol><li><h5 id="Sentinel地址读取错误"><a href="#Sentinel地址读取错误" class="headerlink" title="Sentinel地址读取错误"></a>Sentinel地址读取错误</h5><p>原因：</p><p>Redisson 配置Sentinel模式时， 不可使用redisson-config.yml配置， 读取不到sentinel地址，所以应该自动设置成了localhost。 改成手动配置恢复正常。之所以会这样貌似是因为 redisson的config中， 要直接配置多个地址的话， 需要nodes.toArrayList… 之类的操作。而使用哨兵模式则无可避免需要配置多个地址， 故出错。</p><p>Error Reflection:</p><p>之所以有Sentinel Sentinels return … 这个报错， 因为springboot连接到redis sentinel以后， 会先执行这个命令。 该报错实际就是在 redis-cli中执行 sentinel sentinels +  mymaster（master配置的名字） 返回不到值。 之所以返回不到值，是因为sentinel地址没有读到， 连接到了localhost的默认端口， 所以根本没链接到sentinel。</p><p>关于为什么执行Sentinel sentinels:</p><p>可能性1： health check的目的， 即检测连接的目的。 应该是这个原因， google时候有看到差不多的。 而且该报错可以通过 setCheckList = False 消除。即不让它先查询。</p><p>可能性2： 也可能是因为 Sentinel地址错了以后， 读取不到配置中的Sentinel地址， 所以想通过该指令得到其他sentinel的地址？但是又因为每个sentinel的地址都不对， 所以得不到返回值。）</p></li><li><h5 id="Master-and-Slave地址读取错误"><a href="#Master-and-Slave地址读取错误" class="headerlink" title="Master and Slave地址读取错误"></a>Master and Slave地址读取错误</h5><p>由于在springboot中使用redis的sentinel + MS 模式时， Master and Slave的地址是springboot通过sentinel得到的。 即当sentinel连接成功后， 其会像 springboot返回 master and slave’s ip + port。</p><p>这意味着， springboot中添加的master and slave’s address， 其实是根据sentinel返回的值拼接得到的。 而sentinel返回给springboot的值， 其实就是在redis-cli中 sentinel masters /  sentinel slaves mymaster 显示的 IP值和 Port值。</p><p>而sentinel中的这两个值， 是根据sentinel.conf中的内容获取。 所以如果 sentinle中的 sentinel monitor mymaster IP Port Qurum 中的IP配置的是 127.0.0.1的话， 那么sentinel masters中的ip值就是 127.0.0.1， 所以返回给springboot的值也是localhost。 故连接不到。因此修改的第一步为把sentinel.conf中的localhost改成了VM IP。 修改后master的IP在springboot中正确得到。</p><p>但是Slave的IP依然错误。 并且关闭master，迫使Sentinel重新选主后，新的Master的 IP再次错误。 之所以这样， 是因为：</p><p>​    1） 在 sentinel.conf中， 我们只需要配置，也只能够配置 master的IP。 而slave的IP是sentinel通过master得来的（Sentinel 周期发送的那三个消息， 待复习）。 而master处的slaveIP 无法在master的conf中显示配置， 是自动得到的， 结果就是slave的IP被自动设置成了127.0.0.1。 进而slave在sentinel中存的IP就是127….， which means Springboot从sentinel得到的slaveIP依然是localhost。</p><p>​    2） sentinel会自动修改sentinel.conf中的sentinel monitor…的配置， 所以例如手动配置了  xxx realIP + port1， 再重新选主以后， sentinel也会重新用存储的原slave的IP跟port将该配置项修改为 xxx localhost + newMaster’s Port。 之所以这里IP变成了xxx， 源于above reason 1)。</p><p>解决办法：  配置 slave的conf中的announceIP为VM的真实IP。该项配置指明让server（无论是Master/Slave, 只要其conf中配置了就有效）暴露给外部的IP为设置的announce IP。  进而master得到的就是配置的IP-&gt; sentinel 得到 -&gt; springboot得到。</p><p>总结原因2处理：</p><ol><li>修改sentinel.conf中的sentinel monitor mymaster IP Port Qurum， 使IP为真实VM‘s IP</li><li>配置sentinel.conf中的announce ip</li><li>配置servers.conf中的announce ip, including master and slaves</li></ol></li></ol><p>​        </p><h1 id="压测记录"><a href="#压测记录" class="headerlink" title="压测记录"></a>压测记录</h1><h3 id="v1-2022-01-06"><a href="#v1-2022-01-06" class="headerlink" title="v1 - 2022/01/06"></a>v1 - 2022/01/06</h3><h4 id="Archetecture"><a href="#Archetecture" class="headerlink" title="Archetecture:"></a>Archetecture:</h4><p><strong>Modules and Archetecture:</strong> 单台 秒杀接口 （未开秒杀flash sale entry module 即consumer， 因此也无 loadbalance）+ 单order module + product scan model  + Message MQ;</p><p><strong>redis 中数据结构：</strong> HashTable-&gt; 4 kvs in the value  ==&gt; wait to be updated to store as a list (control as ziplist) and compare the performance</p><p><strong>分布式锁：</strong> redisson</p><h4 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h4><p>单台秒杀接口吞吐量始终 200多， 待测多台 吞吐量是否提升</p><ol><li>4000 并发量 -&gt; 连续测3组 0 Error rate + 0 超卖 </li></ol><p><img src="E:\ShianGit\flash_sale\images\压测\压测\压测2022-01-06\压测2022-01-06.PNG" alt="压测2022-01-06"></p><p><img src="E:\ShianGit\flash_sale\images\压测\压测\压测2022-01-06\库存.PNG" alt="库存"></p><p><img src="E:\ShianGit\flash_sale\images\压测\压测\压测2022-01-06\订单.PNG" alt="订单"></p><p>2)5000并发量 -&gt; 连续测3组 + 1组</p><p>第三组 0.7% Error。 无超卖</p><p><img src="E:\ShianGit\flash_sale\images\压测\压测\2022-01-06-5000\1.PNG" alt="1"></p><p><img src="E:\ShianGit\flash_sale\images\压测\压测\2022-01-06-5000\3.PNG" alt="3"></p><p><img src="E:\ShianGit\flash_sale\images\压测\压测\2022-01-06-5000\2.PNG" alt="2"></p><p>第一， 二组 0 Error 无超卖，  隔2分钟第四组 0Error 0超卖</p><p><img src="E:\ShianGit\flash_sale\images\压测\压测\2022-01-06-5000\v2-1.PNG" alt="v2-1"></p><p>3） 6000并发量 -&gt; 3组</p><p>第一组 0Error 无超卖（图片中总数忘了清空上次结果）</p><p><img src="E:\ShianGit\flash_sale\images\压测\压测\2020-01-06-6000\1.PNG" alt="1"></p><p>第二组0.3Error 无超卖</p><ol start="4"><li>7000 1.99 Error 无超卖</li></ol><p>5） 10000 -&gt; 无超杀 9% Error</p>]]></content>
      
      
      
        <tags>
            
            <tag> sale </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁(1) redisson</title>
      <link href="/2021/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-1/"/>
      <url>/2021/12/22/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-1/</url>
      
        <content type="html"><![CDATA[<h1 id="从伪超杀问题的解决思路及问题演变理解Redisson加锁机制"><a href="#从伪超杀问题的解决思路及问题演变理解Redisson加锁机制" class="headerlink" title="从伪超杀问题的解决思路及问题演变理解Redisson加锁机制"></a>从伪超杀问题的解决思路及问题演变理解Redisson加锁机制</h1><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li><p>功能： 秒杀 –&gt; 高并发</p></li><li><p>架构： nginx + multiple TomCat + Redis Database (Redis中存一简单KV， K = 商品名， V = 库存)</p></li><li><p>Note： 均为伪场景， 实际秒杀问题并非这样设计</p></li></ul><h3 id="V1"><a href="#V1" class="headerlink" title="V1"></a>V1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">deductStock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>));  <span class="comment">// 得到stock数量</span></span><br><span class="line">    <span class="keyword">if</span> ( strock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> realStrock = stock - <span class="number">1</span>;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, realStrok + <span class="string">&quot;&quot;</span>);  <span class="comment">// 写回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        库存不足；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;end&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：</p><p>单机内，TomCat集群皆无锁。</p><p>线程1 得到stock = 200 时， 线程2 也可能得到stock = 200， 两个线程操作后正常数量应为198， 但是均写回了199。</p><h3 id="V2"><a href="#V2" class="headerlink" title="V2"></a>V2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">deductStock</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>));  <span class="comment">// 得到stock数量</span></span><br><span class="line">        <span class="keyword">if</span> ( strock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> realStrock = stock - <span class="number">1</span>;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, realStrok + <span class="string">&quot;&quot;</span>);  <span class="comment">// 写回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            库存不足；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;end&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>evolution1: added Synchronized keyword</p></li><li><p>问题：</p><p>单机内实现了并发安全， 但集群下无效，因为多个TomCat同一时刻下均各自出来一条线程访问redis， 此时依然有线程安全问题</p></li></ul><h3 id="V3"><a href="#V3" class="headerlink" title="V3"></a>V3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">deductStock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String lockKey = <span class="string">&quot;lockKey&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此处不可将设置key与设置超时两个步骤写成两句代码， 因为无法保证原子性， 如设置了key以后宕机了， 那么时间设置就丢失了。</span></span><br><span class="line">    Boolean result = StringRedisTemplate.opsForValue().setIfAbscent(lockKey, <span class="string">&quot;test&quot;</span>, <span class="number">10</span>, TimeUnit.Seconds);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (! result)</span><br><span class="line">retrun <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        nt stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>));  <span class="comment">// 得到stock数量</span></span><br><span class="line">        <span class="keyword">if</span> ( strock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> realStrock = stock - <span class="number">1</span>;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, realStrok + <span class="string">&quot;&quot;</span>);  <span class="comment">// 写回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    库存不足；</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        stringRedisTemplate.delete(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">    i</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;end&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>evolution2:</p><ul><li>利用 redis的单线成特性， <strong>使用setnx指令</strong>， 使各个线程串行的取set一个key， 如果set成功则代表抢锁成功， <strong>此时没抢到锁的线程做自旋等待。</strong></li><li>同时需将key设置expire时间， 其目的是防止程序跑到finally前宕机而无法释放这个key， 也即无法释放锁导致死锁。</li></ul></li><li><p>问题：</p><ul><li>线程实际运行时间超过设置的expire时间， 一个线程还未结束时就释放了锁， 此时线程2拿到锁， 线程2运行过程中线程1运行结束调用finally代码， 从而删除了这个key，也即释放了这个锁。 但问题是此时这个被删除的锁其实是线程2的。 –&gt; 这个现象称为永久失效？</li></ul></li></ul><h3 id="V4"><a href="#V4" class="headerlink" title="V4"></a>V4</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">deductStock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String lockKey = <span class="string">&quot;lockKey&quot;</span>;</span><br><span class="line">    String clientID = <span class="string">&quot;..&quot;</span></span><br><span class="line">    <span class="comment">// 此处不可将设置key与设置超时两个步骤写成两句代码， 因为无法保证原子性， 如设置了key以后宕机了， 那么时间设置就丢失了。</span></span><br><span class="line">    Boolean result = StringRedisTemplate.opsForValue().setIfAbscent(lockKey, clientID, <span class="number">10</span>, TimeUnit.Seconds);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (! result)</span><br><span class="line">retrun <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"> # 更新内存并写回</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ( clientID.equals(redis.get(LockKey)))</span><br><span class="line">        &#123;</span><br><span class="line">            stringRedisTemplate.delete(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    i</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;end&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Evolution:<ul><li>V3的问题是一个线程删除了不属于自己的锁， 也即不属于自己的key， 所以V4将key的value设置成线程唯一的， 再删除key之前先判断这个key是不是自己的</li></ul></li><li>问题：<ul><li>依然会出现一个线程删除了不属于自己的key的情况。 如： key的超时时间为10s, 即10s后一个key会被自动删除。 假设在第9.99999s时， 一个线程运行了finally 中的if条件， 判断if为true， 所以开始执行delete操作。 而在执行delete时， 已经是第10.000001s。 这意味着该线程的key其实已经被自动删除了， 而此时再此执行delete， 则删除的还是另一个线程的锁，即key。</li></ul></li><li>该问题原因：<ul><li>所有线程都用了同一个名称的key，即锁。 –&gt;  无法解决<ul><li>因为，利用redis实现分布式线程安全的本质是利用了“SETNX”， 这意味着所有线程必须使用同一个名称的KEY。</li></ul></li><li>一个线程还未正常运行结束时， key就超时被自动删除了 –&gt; 可解决： <strong>线程运行中为其持有的key续时间</strong>， which is Redisson did。</li></ul></li></ul><h3 id="Redisson-Lock"><a href="#Redisson-Lock" class="headerlink" title="Redisson Lock"></a>Redisson Lock</h3><p>Redisson Lock即帮助自动的为一个线程持有的锁“续命”， 从而避免出现误删其他线程的key的问题。</p><p>总结 Redisson Lock工作原理本质：</p><ul><li>利用SETNX的特点（实际源码中并不是这么写， 但原理是一样的）， 即判断一个key是否存在， 存在即不可持有， 不存在则可更新value， 来实现给线程分发锁。</li><li>使每个线程持有的key中的value唯一， 来实现防止误删的问题。</li><li>使每个线程持有的key自动续命， 来实现防止误删的问题。</li><li>Redisson Lock的源码中大量使用Lua脚本语言来保证操作的原子性。</li></ul><h3 id="Extra-如何提高并发效率？"><a href="#Extra-如何提高并发效率？" class="headerlink" title="Extra: 如何提高并发效率？"></a>Extra: 如何提高并发效率？</h3><p>上述场景中， 所有操作时串行的，例如stock=1000， 那么每个线程都需排队操作者1000个库存。 效率低下。 </p><p>若想提高并发效率， 可将stock分段， 如分成stock_001 = 200,  stock_002 = 200 …. ， 如此并发效率便提高五倍。 同时服务器压力也会增大。 即分段粒度越高， 并发效率越高。</p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sale </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-Spring</title>
      <link href="/2021/12/09/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87-Spring/"/>
      <url>/2021/12/09/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87-Spring/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-树</title>
      <link href="/2021/12/06/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%89%8B-%E6%A0%91/"/>
      <url>/2021/12/06/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%89%8B-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>与树结构相关的题，多为递归求解。 若可确定使用递归求解树相关的题， 则：</p><ul><li>分析问题， 确定解体步骤。</li><li>按照步骤，确定递归函数。 所谓确定递归函数，即以下三个步骤：<ul><li>确定函数终止条件<ul><li><strong>在利用递归解决树相关问题时， 为了确定函数终止条件， 可以从输入的节点的不同状态入手，进而判断何时应该是False, 也即被拦截，或者说被终止。</strong>例如， a, b两个节点都为空则如何， 一个为空如何等等。 同时，如果有可以合并的终止条件， 那么在写if 条件时， 可以利用不同 if 间的顺序达到精简代码的效果。</li><li><strong>并且目前接触到的大部分情况下。 再树中递归时的终止条件基本是拦截所有False的情况， 对于True的情况不需显示写if拦截， 只需让程序继续往下跑即可。 那么通常此时是跑到 return的函数方程， 或者进行某些更改操作。</strong></li></ul></li><li>确定函数功能</li><li>确定递归方程</li><li>切记不要用人脑模拟递归过程！</li></ul></li></ul><span id="more"></span><p>同时， 目前接触到的 “二叉树” 相关的需要递归的题， <strong>要么是需要更改树， 要么是需要判断树是否满足某种条件</strong>，即只需遍历树的个节点值同时做判断，而非更改。 </p><p>仅限目前接触的来说， <strong>当需要更改树的内容时， 可”从下至上“ 更改。</strong> 那么在这种情况下，往往需要通过 前序遍历 先到达树的底部，然后进行更改操作， e.g. offer 26。  通常再这种情况下，代码的结构很可能是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun():</span><br><span class="line">pre_order_traversal(left)</span><br><span class="line">    pre_order_traversal(right)</span><br><span class="line">    do somthing..</span><br></pre></td></tr></table></figure><p>**当不需要更改，只需要判断时， 可”从上至下判断”**。所为从上至下判断， <strong>即每当一个节点进来递归函数， 先对该节点进行判断</strong>， <strong>然后再 return fun(左) and fun(右)。</strong>e.g. offer 28。通常再这种情况下，代码的结构很可能是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用if 过滤所有需被终止的不满足需求的条件。</span></span><br><span class="line"><span class="keyword">if</span> ...</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line"><span class="keyword">if</span> ...</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fun(left) <span class="keyword">and</span> fun(right)</span><br></pre></td></tr></table></figure><p>如果不想用递归， 那么可以使用栈实现， 因为只要能用递归求解的问题， 用栈都可解决， 递归的过程实际也就是计算机进行压栈出栈的过程。其典型代表即为BST的中/前序遍历。</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h4 id="剑指offer-26-判断输入的树B是否是A的子树。"><a href="#剑指offer-26-判断输入的树B是否是A的子树。" class="headerlink" title="剑指offer 26. 判断输入的树B是否是A的子树。"></a>剑指offer 26. 判断输入的树B是否是A的子树。</h4><p>思路：</p><ul><li>确定求解步骤 – 2步，对应两个递归函数：<ul><li>遍历树</li><li>如果发现A中某节点与B的根节点相等， 则检查B的其他节点</li></ul></li></ul><p>注意：</p><ul><li><p>如果面试问到此题， 注意确认输入是否可以为空?， 如果可以的话， 空树是否是子树？</p></li><li><p>体会下列代码中的终止条件判断</p></li><li><p>此题的递归中过程可以理解成是<strong>自下向上在更改树</strong></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_subtree</span>(<span class="params">a: Node, b: Node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    注意 check_subtree中的终止条件的写法和逻辑。</span></span><br><span class="line"><span class="string">    再check_subtree中， 传入的两个参数状态一共五中：</span></span><br><span class="line"><span class="string">    (1) a None b None: true</span></span><br><span class="line"><span class="string">    (2) a None b not None: False</span></span><br><span class="line"><span class="string">    (3) a not None b None: true</span></span><br><span class="line"><span class="string">    (4) a not None b not None =&gt; equal: True, not equal: False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param a:  tree</span></span><br><span class="line"><span class="string">    :param b:  subtree</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_subtree</span>(<span class="params">a_root: Node, b_root: Node</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 能跑到b_root 是空， 则一定是subtree中的之前的节点已经相等了。所有此处为空的话则是b已经遍历完了，返回false</span></span><br><span class="line">        <span class="comment"># 如果这样无法理解， 那么就是 结合（1）（3） 发现，只要b是None， 不管a是不是None， 都为true</span></span><br><span class="line">        <span class="keyword">if</span> b_root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 至此 b_root一定不为None， 也即b not None, a is None 的情况 --》 情况（2）</span></span><br><span class="line">        <span class="keyword">if</span> a_root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> a_root.value != b_root.value:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 至此 一定是状态(4)中的相等</span></span><br><span class="line">        <span class="keyword">return</span> check_subtree(a_root.right, b_root.right) <span class="keyword">and</span> check_subtree(a_root.left, b_root.left)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注意此处， 其中a is None的部分即是对于用户输入的检查，也是递归的终止条件。</span></span><br><span class="line">    <span class="comment"># 而 对b is None的判断则是单纯的用户输入检查</span></span><br><span class="line">    <span class="keyword">if</span> a <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> b <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> a.value == b.value:</span><br><span class="line">        <span class="keyword">if</span> check_subtree(a, b):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> is_subtree(a.left, b) <span class="keyword">or</span> is_subtree(a.right, b)</span><br></pre></td></tr></table></figure><h4 id="剑指offer-28-对称二叉树"><a href="#剑指offer-28-对称二叉树" class="headerlink" title="剑指offer 28. 对称二叉树"></a>剑指offer 28. 对称二叉树</h4><p>思路：</p><ul><li>确定求解步骤 –1步，对应两个递归函数：<ul><li>遍历树, 同时检查两个节点的对称情况。</li></ul></li></ul><p>注意：</p><ul><li><p>注意对input为空值的判断。</p></li><li><p>此题的递归中过程可以理解成是<strong>自上向下在判断树</strong></p></li><li><p>注意体会终止条件和recur 中的return；  </p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    2021-12-6</span></span><br><span class="line"><span class="string">    offer28</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    对称二叉树。 一棵树如果与本身的镜像相同，则为对称二叉树。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    解法：</span></span><br><span class="line"><span class="string">    实际上，要判断对称二叉树，新创建一个“对称前序遍历”的方法，将其结果与正常的前序遍历比较即可。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    但需包括结果中需包括空值， 例子看offer P178</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_symmetrical</span>(<span class="params">root: Node</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当程序运行到这， 说明两个节点的值是相等的，因为可能造成不对称的情况都已被上述终止条件拦截了</span></span><br><span class="line">        <span class="comment"># 那么只需继续判断两个当先节点下的子树是否对称即可</span></span><br><span class="line">        <span class="comment"># 而此处return的这种形式，可以经常被套用再从上至下遍历树的问题。</span></span><br><span class="line">        <span class="keyword">return</span> recur(left.right, right.left) <span class="keyword">and</span> recur(left.left, right.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> recur(root.left, root.right)</span><br></pre></td></tr></table></figure><h2 id="二叉树-BF"><a href="#二叉树-BF" class="headerlink" title="二叉树 BF"></a>二叉树 BF</h2><h4 id="二叉树的层级遍历1-leetcode102"><a href="#二叉树的层级遍历1-leetcode102" class="headerlink" title="二叉树的层级遍历1 leetcode102"></a>二叉树的层级遍历1 leetcode102</h4><p>该题提醒你： <strong>面试写算法时 要问清输出格式。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line"> /   /  \</span><br><span class="line">0   15   7</span><br><span class="line">返回其层序遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [0, 15,7]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">注意， 是[0, 15, 7] 而不是 [[0], [15, 7]]</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>    <strong>注意不可以利用”从上至下“ 的思路， 依次遍历每层中的每个node, 即按照如下错误代码的思路解题：</strong>**<br>    <strong>该代码由你自己写于 2021-12-6， 这个代码的错误在于他的输出形式不符合要求， 即输出了上述”而不是“后面的格式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">node: TreeNode</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            temp = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                temp.append(node.left.val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                temp.append(node.right.val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(temp) != <span class="number">0</span>:</span><br><span class="line">                result.append(temp)</span><br><span class="line"></span><br><span class="line">            traversal(node.left)</span><br><span class="line">            traversal(node.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        result = [[root.val]]</span><br><span class="line">        traversal(root)</span><br></pre></td></tr></table></figure><p>正确定思路：<br><strong>为每个层级标号</strong>， 即维护一个变量level记录当前再那一层， 然后直接把非空的值加入result中的level项。</p><p><strong>实际上使用了深度有限的思想解决此题。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">node, level</span>):</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"><span class="comment"># 如果当前层数为第一次到达， 再result中加入一个新的空列表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(result) &lt; level + <span class="number">1</span>:</span><br><span class="line">            result.append([])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按照level，再result中的level项加入值</span></span><br><span class="line">        result[level].append(node.val)</span><br><span class="line">        </span><br><span class="line">        traversal(node.left, level + <span class="number">1</span>)</span><br><span class="line">        traversal(node.right, level + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    result = []</span><br><span class="line">    traversal(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="二叉树层级遍历2"><a href="#二叉树层级遍历2" class="headerlink" title="二叉树层级遍历2"></a>二叉树层级遍历2</h4><p>与上题不同， 该题的返回值是List[int] 而不是List[[]]， 故要用queue实现。</p><p>事实上，只要看到广度优先遍历的题，则应考虑是否可用queue实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">root</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    result = []</span><br><span class="line">    queue = collections.deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(queue) != <span class="number">0</span>:</span><br><span class="line">        current_node = queue.popleft()</span><br><span class="line">        result.append(current_node.val)</span><br><span class="line">        <span class="keyword">if</span> current_node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queue.append(current_node.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current_node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queue.append(current_node.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="二叉树层级遍历3-（Z字形遍历）-leetcode-剑指offer-32-III"><a href="#二叉树层级遍历3-（Z字形遍历）-leetcode-剑指offer-32-III" class="headerlink" title="二叉树层级遍历3 （Z字形遍历） leetcode 剑指offer 32 - III"></a>二叉树层级遍历3 （Z字形遍历） leetcode 剑指offer 32 - III</h4><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><p>​    3</p><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：</p><p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p><p>思路：</p><ul><li>由于对于不同层级的节点需要改变输出顺序， 故用单个队列无法实现</li><li>改变思路为用两个栈实现</li><li>一个栈对应奇数层的所有节点， 从右至左压入。 另一个对应偶数层，从左至右压入</li></ul><p>注意理解：</p><ul><li>一个栈中的节点全部被弹出时，就代表该层已经遍历结束</li><li>弹出后只需要： <ul><li>append到temp</li><li>将子节点压入另一个栈</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bst_review <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">root: Node</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    result = []</span><br><span class="line">    stack_push_from_left = []</span><br><span class="line">    stack_push_from_right = [root]</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(stack_push_from_left) != <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(stack_push_from_right) != <span class="number">0</span>:</span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack_push_from_right) != <span class="number">0</span>:</span><br><span class="line">            node = stack_push_from_right.pop(-<span class="number">1</span>)</span><br><span class="line">            temp.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack_push_from_left.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack_push_from_left.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> temp:</span><br><span class="line">            result.append(temp)</span><br><span class="line">            temp = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack_push_from_left) != <span class="number">0</span>:</span><br><span class="line">            node = stack_push_from_left.pop(-<span class="number">1</span>)</span><br><span class="line">            temp.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack_push_from_right.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack_push_from_right.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> temp:</span><br><span class="line">            result.append(temp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="平衡二叉树DF"><a href="#平衡二叉树DF" class="headerlink" title="平衡二叉树DF"></a>平衡二叉树DF</h2><h4 id="后续遍历非递归"><a href="#后续遍历非递归" class="headerlink" title="后续遍历非递归"></a>后续遍历非递归</h4><p>Overall Procedure:</p><ul><li>压左</li><li>压左结束， 检查栈顶元素是否满足输出条件：<ul><li>栈顶元素应该被输出 –&gt; 没有右子树， 或者右子树已经被输出过</li><li>不应被输出 –&gt; 右子树还为被压栈，也即还没被输出–&gt; cur  = cur.right循环压左。 </li></ul></li></ul><p>关键：</p><ul><li>左-右-根</li><li>只需记住点为：<ul><li>需维护一prev记录是否当前节点可以被记录至result。</li><li><strong>只有当 cur.right为空 或 cur.right == prev时 可以被输出， 此时做三件事。</strong><ul><li>pop stack</li><li>update prev</li><li>cur = None. <strong>目的为实现循环，因为cur is None时不会进入第一个循环。</strong></li></ul></li><li>不可以被输出则代表右侧子树还未被输出， 则只需 cur  = cur.right即可实现循环。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_order_traversal_non_recursive</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">     2021-12-19</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cur = self.root</span><br><span class="line">    stack = []</span><br><span class="line">    result = []</span><br><span class="line">    prev = self.root</span><br><span class="line">    <span class="comment"># 压至最左</span></span><br><span class="line">    <span class="comment"># 之所以加 cur is not None是为了最开始能进入循环</span></span><br><span class="line">    <span class="comment"># 因为stack初始为空， 不加这个条件进不来，同时也不能更改while cur is not None这个条件。</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> <span class="keyword">or</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.left</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此处不弹出，而是检查</span></span><br><span class="line">        cur = stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断append到结果与否</span></span><br><span class="line">        <span class="comment"># 如果cur.right为空， 那么此时必然输出value，因为当程序到此处时， 已经压至最左</span></span><br><span class="line">        <span class="comment"># 如果cur.right不为空，但是cur.right == prev， 则代表当前节点的右侧子树已经全部输出，可以输出当前节点了。</span></span><br><span class="line">        <span class="keyword">if</span> cur.right <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> cur.right == prev:</span><br><span class="line">            <span class="comment"># 只要需要append结果： 则更新prev</span></span><br><span class="line">            <span class="comment"># 弹出stack</span></span><br><span class="line">            <span class="comment"># 使cur=None实现循环目的</span></span><br><span class="line">            result.append(cur.value)</span><br><span class="line">            stack.pop(-<span class="number">1</span>)</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果不符合上列判断，则两种情况：</span></span><br><span class="line">            <span class="comment"># 当前节点的右子树还没有被输出， 则此时cur.right不为空， 会继续到第一个while压左</span></span><br><span class="line">            <span class="comment"># 或者当前节点的cur.right为空，即已经没有右子树， 则会略过第一个while， 继续检查输出与否</span></span><br><span class="line">            cur = cur.right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="中序遍历非递归"><a href="#中序遍历非递归" class="headerlink" title="中序遍历非递归"></a>中序遍历非递归</h4><p>Overall Precedure:</p><ul><li>压左</li><li>pop， 只要pop就输出</li><li>检查右子树是否存在， 存在则继续压左</li><li>否则循环pop，方法为使cur = None</li></ul><p>注意点：</p><ul><li>整体代码逻辑三个顺序遍历都一样。</li><li>记住只要pop就输出即可。</li><li>若是前序遍历， 则改成只要push就输出即可。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = root</span><br><span class="line">        stack = []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> <span class="keyword">or</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 压左</span></span><br><span class="line">            <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 至此， 一定是最左元素， 所以必pop，且只要pop就输出</span></span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            result.append(cur.val)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># pop过后检查右子树即可</span></span><br><span class="line">            <span class="comment"># 此处逻辑与后续遍历一样， 如果有右子树， 则循环使用第一个while</span></span><br><span class="line">            <span class="comment"># 无右子树， 则使cur=None就可略过第一个while， 继续pop</span></span><br><span class="line">            <span class="keyword">if</span> cur.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="剑指offer33-判断数组是否可以是后续遍历结果"><a href="#剑指offer33-判断数组是否可以是后续遍历结果" class="headerlink" title="剑指offer33. 判断数组是否可以是后续遍历结果"></a>剑指offer33. 判断数组是否可以是后续遍历结果</h4><p>Overall Precedure:</p><ul><li>只需记住一个数组若是BST的后序遍历结果， 那么最后一个元素必是根节点， 而之前的元素必是左+右。</li><li>因此左子树中不能有大于root的元素</li><li>右子树中不可有小于root的元素</li><li>之后递归求解即可</li></ul><p>注意：</p><ul><li>此题终止条件不是常规的在函数起点直接if判断。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_back_order_traversal</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    2021-12-19</span></span><br><span class="line"><span class="string">    思路：</span></span><br><span class="line"><span class="string">    判断树的后序遍历， 则首先需明确其特点：</span></span><br><span class="line"><span class="string">    数组最后一位必为根节点。 那么根节点之前的elements， 必为左右子树， 且左右子树连续， 即必一组都小于root的+一组都大于root的</span></span><br><span class="line"><span class="string">    e.g. [5, 7, 6, 9, 11, 10, 8] --&gt; root = 8; left = [5, 7, 6]; right = [9, 11, 10, 8]</span></span><br><span class="line"><span class="string">    那么此时， 继续判断left和right是否符合条件即可。 上例中， 如果right = [9, 1, 11, 10, 8]则不符条件， 因为右子树中无小于root</span></span><br><span class="line"><span class="string">    的元素</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    至此， 可确定必为使用递归解决。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    递归：</span></span><br><span class="line"><span class="string">        递归函数作用：</span></span><br><span class="line"><span class="string">            判断当前列表是否符合后续遍历条件</span></span><br><span class="line"><span class="string">        函数方程：</span></span><br><span class="line"><span class="string">            left and right 则True</span></span><br><span class="line"><span class="string">        函数终止条件：</span></span><br><span class="line"><span class="string">            当list长度小于等于2， 则必为True；</span></span><br><span class="line"><span class="string">            当右子树中出现比root小的元素， 则为false；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        此题特殊点在于终止条件不是简单的写于前面的if， 而是先找到左右子树， 再判断右子树是否符合。</span></span><br><span class="line"><span class="string">        之所以说只需判断右子树， 是因为第一while中的左子树一定是符合条件的。 因为找到的元素都是小于root的。</span></span><br><span class="line"><span class="string">    :param nums:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recursive</span>(<span class="params">nums</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        root = nums[-<span class="number">1</span>]</span><br><span class="line">        left_end = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left_end &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[left_end] &lt; root:</span><br><span class="line">            <span class="comment"># 此处注意， [5, 7, 6, 9, 11, 10, 8]中， 第一次遍历时实际left_end应该等于2, 但是这里是等于3的， 因为Left_end先</span></span><br><span class="line">            <span class="comment"># 加了1才判断不符合while条件。 所以再return中切片时， 切成[0: left_end]正好符合所需。</span></span><br><span class="line">            left_end += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left_end, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 注意and后的切片范围不要弄错，传入下一个递归中的数组不要带上当前root。</span></span><br><span class="line">        <span class="keyword">return</span> recursive(nums[<span class="number">0</span>:left_end]) <span class="keyword">and</span> recursive(nums[left_end:<span class="built_in">len</span>(nums)-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recursive(nums)</span><br></pre></td></tr></table></figure><p>Created by Shain at 2021/12/06, Mel, Australia</p><p>Last Updated:  2021/12/19</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Data Structure </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-链表</title>
      <link href="/2021/12/05/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%89%8B-%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/12/05/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%89%8B-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>See code in Git Repository/Leetcode-algorithm/data_structure/Linked_list</p><p>Most in Link_List_Review.py</p><h2 id="链表的环"><a href="#链表的环" class="headerlink" title="链表的环"></a>链表的环</h2><h3 id="判断是否有环："><a href="#判断是否有环：" class="headerlink" title="判断是否有环："></a>判断是否有环：</h3><ul><li>维护快慢两个指针， 快指针一次前进两位，慢指针一次一位。 若两个指针能够相遇，则有环。 若快指针运动到末尾还未与满指针相遇则无环。</li><li>注意， 如果有环，则使用 while node.next is not None为判断条件时，一定会有快慢指针相遇的时候， <strong>因为如果有环的话， 那么链表就没有尾节点，也就是没有next为None的节点。换句话说， 如果链表有尾节点，也就是next 为none的节点，那么链表一定无环。</strong></li></ul><p><em>More in Detail update at 16/04/2023</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快慢指针同向奔跑， fast 的速度是slow的一倍， 如果有环， 那么两者必定在某一点相遇， 也即fast会追上slow， 此时fast正好比slow多走了一圈的路程。</strong></p><h3 id="找到链表环的入口："><a href="#找到链表环的入口：" class="headerlink" title="找到链表环的入口："></a>找到链表环的入口：</h3><ul><li>首先使用上述方法判断是否有环</li><li>找到环中任意一个节点。 <ul><li>方法： 若有环， 则使用上述方法判断过程中会得到两个指针相遇的节点。</li></ul></li><li>当快慢指针相遇时，创建一新指针从头节点出发， 当该新指针与慢指针相遇时所处的结点即为环的入口。</li></ul><p><em>More in Detail update at 16/04/2023</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若链表无环， 则fast会走到链表结尾， 而此时slow还在链表中间。</span></span><br><span class="line"><span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果链表中没有环， 该while condition 中的前两个条件会跳过该while， 直接return。</span></span><br><span class="line"><span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span> &amp;&amp; slow != fast) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果fast为null 或者fast.next为null， 代表链表无环</span></span><br><span class="line"><span class="keyword">return</span> fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>? <span class="keyword">null</span>: slow;</span><br></pre></td></tr></table></figure><h4 id="Explaination"><a href="#Explaination" class="headerlink" title="Explaination"></a>Explaination</h4><p>slow 路程 = x + y; fast 路程 = x + y + n(y + z) </p><p>由于 fast = 2 slow:     </p><p>2(x+y) = x+y + n (y+z)； </p><p>x + y = n (y + z)</p><p>x = (n-1) y + nz</p><p>其中n为fast在环中跑的圈数。在相遇时， fast指针最少在环中已经跑了一圈， 所以 n &gt;=1。</p><p><strong>假设 n = 1， 则得 x=z, 也即当slow&amp;fast相遇以后， 使得slow在head开始跑， fast在meeting point开始跑， 则两者必定在entry poin相遇。</strong></p><p><img src="https://shain001blog.oss-ap-southeast-2.aliyuncs.com/blog%E7%AC%94%E8%AE%B0%202023%E5%B9%B44%E6%9C%8815%E6%97%A5.jpg" alt="笔记 2023年4月15日"></p><h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h3><p>使pA， pB两个指针分别从headA和headB出发， 当pA跑完了A链以后， 使其从B链头节点继续跑， pB 同理。 </p><p>当pA=pB时， 要么两者相遇在相交节点， 要么两者同时跑到链表结尾， 即 null = null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    ListNode pA = headA;</span><br><span class="line">    ListNode pB = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">        pA = pA == <span class="keyword">null</span>? headB: pA.next;</span><br><span class="line">        pB = pB ==<span class="keyword">null</span>? headA: pB.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若没有交点， while将在pA = pB = null 时退出循环</span></span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h4><p>当P1 第二次经过交点 I 时， 其走过的距离 = (M + N) + Z;</p><p>同理， 当P2 第二次经过交点时， 其走过的距离 = (N + Z ) + M;</p><p><strong>两者相等。所以只要有交点， P1 &amp; P2 必相交于交点处。</strong></p><p><img src="https://shain001blog.oss-ap-southeast-2.aliyuncs.com/blog%E9%93%BE%E8%A1%A8-2.jpg" alt="链表-2"></p><p><strong>若两条链没有交点， 假设 ListA = X, ListB = Y.</strong></p><p><strong>则当P1 遍历完两条链走到null 时， 其路程为 X + Y。 同理， P2的路程为Y + X。 所以只要两条链表没有相交， 两者必在 null 处相遇。</strong></p><h3 id="链表的倒数第K个元素-offer"><a href="#链表的倒数第K个元素-offer" class="headerlink" title="链表的倒数第K个元素 - offer"></a>链表的倒数第K个元素 - offer</h3><ul><li>注意双指针在链表中的使用：<ul><li>倒数第k个元素， 可使快指针先走k步， 然后慢指针再开始走，这样当快指针走到末尾慢指针所指即答案。</li></ul></li><li><strong>注意代码鲁棒性</strong>：<ul><li>所谓鲁棒性即注意对input的检查， 通常再写算法时表现再程序入口的几个 if-return。 很重要，勿忘。</li><li>再此题中包括：<ul><li>链表是否为空？</li><li>k是否为0？</li><li>链表长度是否大于k？</li></ul></li></ul></li></ul><h3 id="链表的反转"><a href="#链表的反转" class="headerlink" title="链表的反转"></a>链表的反转</h3><ul><li><p>recursive即可</p></li><li><p>但是注意：</p><ul><li>不要忘了把原头节点的next置空</li><li>终止条件应为：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">不应使用cur_node is None 为if条件，因为不好记录新的头节点</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> cur_node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    cur_node.<span class="built_in">next</span> = pre_node</span><br><span class="line">    self.head = cur_node</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Data Structure </category>
          
          <category> LinkList </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM (3) -JVM Memory Model Part A: Main Memory and Working Memory and their communication</title>
      <link href="/2021/12/04/JVM-3-JVM-Memory-Model-Part-A-Main-Memory-and-Working-Memory-and-their-communication/"/>
      <url>/2021/12/04/JVM-3-JVM-Memory-Model-Part-A-Main-Memory-and-Working-Memory-and-their-communication/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-Memory-Model-JMM-Overview"><a href="#Java-Memory-Model-JMM-Overview" class="headerlink" title="Java Memory Model (JMM) Overview"></a>Java Memory Model (JMM) Overview</h2><p>所谓JMM即可粗略理解为 “JVM中为针对变量在内存中写入写出而制定的一系列规则”， 也即以线程安全为主要目标的一系列底层基础设计。其存在目的即为： “<strong>使程序再各种不同架构的系统中都可保证并发安全， 即保证原子性，可见性，有序性</strong>”</p><p>该篇文章涵盖以下内容：</p><ul><li>JVM中线程的通信</li><li>JVM中工作内存与主内存交互的8个基本操作</li><li>JVM中针对上述八个基本操作而指定的几条基本规则</li><li>从JMM角度解释线程安全问题的根本原因</li><li>JVM中的原子性， 可见性及有序性</li></ul><span id="more"></span><h4 id="JVM中线程的通信"><a href="#JVM中线程的通信" class="headerlink" title="JVM中线程的通信"></a>JVM中线程的通信</h4><p>JVM中的内存被分为<code>工作内存</code>与<code>主内存</code>， 其中主内存为所有线程共享， 也即主内存中的内容对于所有线程均是可见且可访问的， 而工作内存则为线程私有。 每条线程均拥有自己的工作内存， 且线程间不可访问对方的工作内存。</p><p><strong>在JVM中， 所有变量均存储在主内存中，</strong> <strong>工作内存若需使用某个变量，则需从主内存中拷贝一份变量副本</strong>， 然后对副本进行操作， 最后写回主内存。 注意， <strong>此处的变量特指线程共享的变量</strong>， 包括 instance’s fields, static fields, and elements of array， 其不包括线程私有的变量，即局部变量和方法参数等。 </p><p>由于线程间不能互相访问对方的工作内存， 那么为了实现线程间的通信，就只能通过一个“第三方” — 主内存。其具体方式为： <strong>“若线程A与线程B间想要实现通信， 则A需先将变量值写回主内存， 之后线程B从主内存中复制该值， 进而实现通信目的”</strong></p><h4 id="工作内存-amp-主内存-VS-堆-amp-栈"><a href="#工作内存-amp-主内存-VS-堆-amp-栈" class="headerlink" title="工作内存&amp;主内存 VS 堆&amp;栈"></a>工作内存&amp;主内存 VS 堆&amp;栈</h4><p>至此， 你可能会认为主内存即对应着JVM中的堆， 而工作内存则对应着JVM中的栈。 然而， <strong>实际上工作内存/主内存 与堆栈并非同一Scope下的概念</strong>。 如果一定要将两个概念向类比， 那么工作内存可对应位堆中的<strong>实例数据部分</strong>， 而工作内存可对应为栈中的<strong>部分数据</strong>。</p><p>首先， 之所以说两者属于不同的Scope, 是因为主内存对应于物理内存， 工作内存则会有限被存储于寄存器和缓存中（因为程序运行时主要访问的是工作内存， 而将工作内存放置于寄存器和缓存可提高运行速度）。</p><p><strong>同时，堆中不仅仅是实例数据，栈中也不仅仅是局部变量</strong>。 上文提到工作内存的作用为存放线程共享变量， 但尽管成员变量，类变量，数组元素等共享变量是存储与堆中， 这些变量仅仅对应着堆中的实例数据的部分，而非全部。 因为堆中除了存储实例数据以外， 还包含着Object Head and padding。具体来讲， 当一个对象被new到堆中以后， 其在堆中的结构由三部分组成： Object Head + 实例数据 + padding。 其中Object Head 中存放着 Mark Word + 类型指针。Mark Word作用为存储 锁状态， GC年龄等， 类型指针作用为指明该实例所属的是哪个类。</p><h4 id="JVM中工作内存与主内存交互的8个基本操作"><a href="#JVM中工作内存与主内存交互的8个基本操作" class="headerlink" title="JVM中工作内存与主内存交互的8个基本操作"></a>JVM中工作内存与主内存交互的8个基本操作</h4><p>交互所需的8个基本操作即在实现工作内存与主内存的交互过程中所需要的八个最基本操作。 也即不论你要进行何种复杂的操作， 其皆为这八个基本操作中的多个或全部组成。</p><p>八个基本操作如下：</p><ul><li>lock: 对主内存中某一变量上锁，使其只可被一条线程独占。 同一时间只有一条线程可对一个变量lock。</li><li>unlock： 解锁， 且解锁后才可被其他线程Lock。</li><li>read： 作用于主内存变量，将该变量的值传输到工作内存中， 之后才可进行load。 <strong>即主内存中的值传入工作内存中的过程。 仅指“传输”</strong>。</li><li>load： 作用于工作内存，将read进来的变量放入工作内存的副本。 <strong>即将“传输”进来的变量值， 更新到工作内存中的过程。 仅指“更新/对工作内存的内存赋值”</strong>。</li><li>use： 于工作内存，将工作内存中变量的值交给执行引擎进行操作。</li><li>assign： 于工作内存，接受工作引擎操作后的值，然后将其赋值回工作内存。 注意，<strong>此处可以发现工作引擎与工作内存间的交互过程不同于工作内存与主内存间的交互过程。 后两者交互过程中“传输”和“更新”是分开的， 而前两者则是一体的。</strong></li><li>store： 作用于工作内存，把工作内存中的变量值发给主内存。<strong>即工作内存中的值传入主内存的过程。 仅指“传输”</strong>。</li><li>write： 作用于主内存变量，将store进来的值更新到主内存。<strong>工作内存中的值传入主内存以后， 工作内存更新内存中的值的过程。 仅指“更新”</strong>。</li></ul><p>其中， <strong>“store/write and read/load 操作之间一定是顺序执行，但不一定是连续执行，即store and write之间， read and load之间，是可以插入其他指令的”。 这就是线程不安全的根源所在。</strong></p><p>同时， <strong>这八个操作都为原子性</strong>，但是在某些架构的系统中，对于long/double的读写可能不具有原子性，因为是64位占两个格子。</p><h4 id="JVM中工作内存与主内存交互的几条基本规则"><a href="#JVM中工作内存与主内存交互的几条基本规则" class="headerlink" title="JVM中工作内存与主内存交互的几条基本规则"></a>JVM中工作内存与主内存交互的几条基本规则</h4><p>在执行上述八个操作时， 必须满足下列规则：</p><ol><li>read &amp; load 以及 store &amp; write  必须不可单独出现，及read 必load， store必write；即， 如果工作内存从主内存中复制来一个值， 则必须在工作内存中写入这个值。同理， 当主内存从工作内存中接受了一个值， 也必须在主内存中更新该值。</li><li>不允许一个线程丢弃它最近的assign操作，即<strong>变量在工作内存中改变了之后必须把该变化同步回主内存。</strong></li><li>没有assign操作则不可将变量更新回主内存。 也即， 若想将一个变量值写回主内存， 则其前提是这个变量值已经被工作引擎使用完且已经写回了工作内存。</li><li>只有主内存可生成新的变量，不可由工作内存自己生成新的变量， 即use, store 之前必有assign 和load。</li><li>一个变量同一时间只可被一条thread lock, but can be locked many times。若被上锁多次， 则也许被解锁同样次数。</li><li>当执行lock操作后，工作内存中该变量的值将被清空，在use之前需重新进行Load 或 assign操作以”初始化”(this is why assign is also  OK)该变量的值。<strong>即在线程对于一个变量上锁后， 必定要重新read&amp;load该变量的值。</strong></li><li>只可由lock的线程进行unlock， 且one var can only be locked by one thread。</li><li><strong>unlock之前，必须将变量值更新回主内存。</strong></li></ol><p>此八个规则的设定目的即在于<strong>保证并发安全</strong>。对于这八个规则， 只需记住：<strong>“这八个规则的存在， 以及volatile的特殊规则，共同保证了JVM中的并发安全”</strong></p><h4 id="JVM中的原子性，-可见性及有序性"><a href="#JVM中的原子性，-可见性及有序性" class="headerlink" title="JVM中的原子性， 可见性及有序性"></a>JVM中的原子性， 可见性及有序性</h4><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>DEF: </p><p>即一个变量值被修改后，其他线程可<strong>立即</strong>见到这个值。</p><p>JVM中的保证措施： </p><p>通过 “<strong>在使用前刷新值，使用后写回主内存</strong>“ 保证, no matter it is volatile variable or ordinary one。 两这区别在于 volatile 随时可见，普通变量写回后可见。</p><p>volatile, synchronized, final均可保证可见性。</p><p>synchronized 可保证是因为 <strong>synchronized 在底层实现其实就是 lock and unlock,</strong> 而上述规则中规定， JVM内存模型规定进行 unlock操作必须进行store and write 操作， 也即<strong>必须将值更新回主内存后才可unlock</strong>。</p><p>而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值</p><p>这里可体现 synchronized and volatile 一个区别， volatile相当于系统自动的， 在变量值更新后自动写回主内存，且在某线程要使用volatile变量时自动刷新，，<strong>进而可随时保证可见性</strong>。  而 <strong>synchronized 只有在unlock后在能保证了可见性</strong>。</p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>DEF: </p><p><strong>原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败</strong>。及时在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。</p><p>JVM中的保证措施：</p><p> 由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个。我们大致可以认为，基本数据类型的访问、读写都是具备原子性。 例如， a=10这个操作是原子性的， 而a++ 则不是。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>有序性指： <strong>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的</strong>。前半句是指“线程内似表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p><p>JVM中的保证措施： </p><ol><li>防止指令重排 – volatile关键字</li><li> 同一时间内一个变量只可被一条线程lock, 也即保证一时间内只有一个线程可操作某个变量 (这是因为 其保证了持有同一个锁的两个同步块<strong>只可</strong>串行的进入) – synchronized 关键字</li></ol><p>Created by Shain at 2021/12/4, Melbourne, Australia.</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMM </tag>
            
            <tag> JVM Working Memory </tag>
            
            <tag> JVM Main Memory </tag>
            
            <tag> JVM Thread Communication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM (2) 内存分配与回收(GC)</title>
      <link href="/2021/12/03/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/"/>
      <url>/2021/12/03/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Overall"><a href="#Overall" class="headerlink" title="Overall"></a>Overall</h2><p>C/C++中， 当一个对象被创建后， 需要手动调用方法回收内存， 而在Java中这个工作由Java负责， 这也就是所谓内存回收与分配策略的根源。</p><p>在Java中， 内存的回收主要集中在堆， 次要集中在方法区。 而与之相对的， 非线程共享的三个区域（主要指Stack）则并非垃圾回收重点。 其原因在于， 由于Java中的动态连接的存在，包括数组在内的很多对象的创建只有在运行期间才可确定。 这就导致了 方法区与堆的内存分配往往是动态的， <strong>因为对象的创建过程也就是向堆与方法区中内存写入内容， 索要空间的过程</strong>。相比之下， Stack中栈帧的内容在编译期间即可大概确定，其在运行期间也不会有太多变化，进而导致此部分不是垃圾回收的重点内容。 也就是说， <strong>某个分区是否是内存回收的重点对象与否， 取决于该区域的内存是否是动态的， 也即该区域的内存是否在编译期间即可确定。</strong></p><p>而这种对于内存回收的需求， 也就导致了各种内存回收的策略与方法， <strong>同时也促使了内存分配策略的诞生</strong>。 总的来说， 内存回收中的主要问题为”<strong>删除对象后造成的内存空间不连续</strong>“， 以及”<strong>为了防止空间不连续而进行的对象复制整理过程中产生的开销</strong>“。 这两个问题之间， 至少从目前笔者所接触到的内容而言， 有着不可避免的trade off problem。 因此， 不同的垃圾回收算法应运而生。 随之而来的还有三条<strong>分代假说</strong>。.</p><p>所谓分代假说可理解为对”对象存活时间的假定“。 在这三条假说的帮助下，对象被assume为短期对象与长期对象。 如果对两种对象的回收分别使用不同的垃圾回收算法， 即将所有短期对象与长期对象分别集中在一起并对两个区域使用不同的垃圾回收算法， 那么上述提到的trade off problem即可在一定程度上被缓解。 这就是为什么内存分配是为了方便内存回收。</p><span id="more"></span><h2 id="JVM-内存回收-i-e-Garbage-Collection"><a href="#JVM-内存回收-i-e-Garbage-Collection" class="headerlink" title="JVM 内存回收 i.e. Garbage Collection"></a>JVM 内存回收 i.e. Garbage Collection</h2><h3 id="垃圾的判定"><a href="#垃圾的判定" class="headerlink" title="垃圾的判定"></a>垃圾的判定</h3><p>要对垃圾进行回收， 那么首先要解决的问题即是如何判定一个对象为垃圾。 通常认为一个对象如果不被任何其他对象所使用，那么该对象就是应该被回收的。 至此， 垃圾的判定问题也就被转化为对于 ”一个对象是否被引用的判定问题“。 而针对这个问题， 如下两个方法被提出：</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>引用计数法即为每个对象维护一标志位用于记录该对象被引用的次数。</p><p>但此方法会由于<strong>循环引用</strong>而产生错误。所谓循环引用即： 三个垃圾对象 A，B，C， A引用B， B引用C， C引用A。 此场景下ABC的计数位均不为0， 即都不会被标记为垃圾， 但实际上三个对象均是垃圾。 因此在JVM中被使用的是根可达算法。</p><h4 id="根可达算法"><a href="#根可达算法" class="headerlink" title="根可达算法"></a>根可达算法</h4><p>即通过查询从”根对象”出发的“引用链”， 判断那些对象不在引用链中，若一个对象不在引用链中则代表其永远不会被调用，进而应该被回收。</p><p>根对象包括：</p><ul><li>在虚拟机栈中的引用对象，即栈帧中局部变量表中的引用的对象。 i.e. 程序中的方法中的 参数，局部变量，临时变量等；</li><li>方法区中的类静态属性引用的变量，例如static的变量等；</li><li>JNI引用的对象（Java Native 方法）</li><li>Java虚拟机内部的引用， 如基本数据类型对应的Class对象，系统类加载器等</li><li>被synchronized关键字持有的对象</li><li>反应JVM内部情况的JMXBean等</li></ul><h3 id="垃圾回收算法-主要针对Heap"><a href="#垃圾回收算法-主要针对Heap" class="headerlink" title="垃圾回收算法 - 主要针对Heap"></a>垃圾回收算法 - 主要针对Heap</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>DEF: 即先标记死亡对象，在直接将其清楚</p><p>Drawbacks: </p><ul><li><p>会造成内存不连续</p></li><li><p>当对象数量极多时，标记清除的数量增多，效率降低</p></li></ul><h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>DEF: 将内存分区，按容量只使用其中一部分，当需要垃圾回收时，将存活的对象复制到未使用的那部分内存，然后将使用的内存一次性全部删除.</p><p>该算法其中一种实现为apple算法, 而apple算法正是对于堆分区进一步进行划分的原因。 <strong>该实现将新生代区域分成三块，eden区和两个suvivor区。三块区域中，其中的一个suvivor区为日常不使用的区域，只用来复制存活对象，然后清空整个eden+ 使用过的那个suvivor</strong></p><p>Drawbacks: </p><ul><li><p>对象多时复制将变得heavy</p></li><li><p>会浪费一部分内存日常无法使用</p></li></ul><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>DEF: 即在标记后，将所有存活的对象移动到内存中的一块区域，然后清理掉其他区域。该算法与“标记-复制”算法的本质思路相同。 其唯一区别在于， 不维护一块空间日常不使用， 而是在垃圾清理时，把所有或者的对象复制到内存中的一块区域，进而解决了 浪费内存的问题。</p><p>Drawbacks:</p><ul><li>移动对象很heavy</li><li>该操作需暂停用户进程</li></ul><h3 id="方法区回收"><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h3><p>方法区回收则主要回收”<strong>废弃的常量</strong>“以及“<strong>废弃类型</strong>”。</p><p>对于废弃的常量的回收与对 对象的回收很类似。 例如一个字符串曾进入常量池， 但其已经不在被使用，则会被清理。 其他常量池中的类， 方法符号引用皆为同理。</p><h2 id="JVM-内存分配"><a href="#JVM-内存分配" class="headerlink" title="JVM 内存分配"></a>JVM 内存分配</h2><p>为了方便内存回收管理， JVM中的堆进一步被分为： <code>新生代</code> 与 <code>老年代</code>。依据对象年龄，将其集中分配于堆中的不同区域以达到方便管理回收内存的作用。 而分配的合理性即为三条分代假说。 此处需注意， 所谓对堆的进一步划分是从GC角度而言， JVM规范并未对此有规定。换句话说， 对于堆的区域划分由不同的JVM实现决定。</p><p>有了新生代与老年代以后， 即可对于不同的分区采取不同的垃圾回收算法。同时也可以只对其中一个分区进行GC操作。 不同的GC操作分为：</p><ul><li>Minor GC：只对新生代GC</li><li>Major GC：只对老年代GC</li><li>Full GC： 收集整个Java堆和方法区的垃圾收集 </li></ul><h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><p>所谓新生代即”熬过GC次数较少的“对象。 新生代区域又分为 Eden 空间和Survivor空间。 Survivor空间有进一步分为To_Survivor &amp; From_Survivor。</p><p>其中Eden空间占新生代整个空间的 8/10， 其余两个survivor空间分别占1/10。 而新生代空间整体又占整个堆的1/3。 但注意这些比例皆可调整。</p><p><strong>新对象通常创建在Eden空间， 若Eden空间内存不够， 则发起依次Minor GC</strong>。 新生代空间中使用的GC算法是<strong>标记-复制算法</strong>， 之所以使用该算法， 依据的是三条分代假说中的<strong>弱分代假说—- 绝大多数对象都死的快</strong>。 因为有了大多数新生对象都死的快这个前提， 使得<strong>”复制这个操作不会很Heavy， 因为大多数新生代中的对象都将被清除， 每次复制的对象仅是很少一部分“</strong>。</p><p>同时使用在新生代中的假说还有 <strong>”跨代引用假说 —- 跨代引用只占极少一部分“</strong>。 该理论意义为，其使得系统无需在为了少量的跨代引用扫描整个老年代，也不必浪费空间为每个对象记录是否存在跨代引用，取而代之的是在新生代中建立一个全局数据结构记录老年代中哪一块内存存在跨代引用，只有其中记录的老年代才会加入GC Roots的扫描。</p><p>简单说， 当进行Minor GC时， 是跨代引用假说避免了扫描所有老年代。 如果不建立这条假说， 那么由于鼓励老年代可能引用新生代对象， 进而只对新生代进行回收时还需扫描整个老年代。</p><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p><strong>大对象将直接进入老年代， 而所谓大对象， 即指”需要大块连续内存的对象“， 比如长字符串， 长数组等。</strong> <strong>除了大对象外， ”熬过多次垃圾回收的对象“也将被移至老年代。 这也是依据了强分代假说</strong></p><p>具体来讲， 对象通常被创建在新生代Eden区， 而每个对象被创建时， 其对象头内会被设置一”年龄计数器“， 每当一个对象熬过一次GC， 则年龄加1， 当一个新生代中的对象经过第一次Minor GC后仍存活， 且Survivor能够容纳它的话， 则该对象被转移至survivor空间。 当age超过设定值（默认15）， 则会被转移至老年代</p><p>同时， 由于大对象将直接进入老年代，  那么频繁的创建生命很短的大对象则是一个很”繁重“的操作。原因在于大对象需要大块连续内存开销， 进而可能触发GC操作， 并且 当进行复制操作时， 大对象意味着很高的复制开销。</p><p>Created by Shain at 2021/12/3, Melbourne, Australia.</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
            <tag> JVM Memory Allocation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM (1)-JVM Memory Area</title>
      <link href="/2021/12/02/JVM-1-JVM%E5%88%86%E5%8C%BA/"/>
      <url>/2021/12/02/JVM-1-JVM%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Java is the well-known language that has the slogan “write once, run everywhere”, and the exist of JVM is exactly the reason why this slogan can be achieved. Specifically, when we write and run the Java code, the .java file is ultimately translated into bytecode, and then be loaded in the JVM to be implemented. This means that as long as we have a JVM in our machine, we can run the compiled JAVA file whatever the OS we are using. </p><p>JVM divides the memory into different parts to better manage it, we can say the the process that JVM load and create a Class/Instance is exactly the process that it put data into different parts of memories. </p><p>There are FIVE areas in JVM memory, with 2 of them are shared by threads (Heap, Method Area) and 3 of them (Stack, Native Method Stack, Program Counter) are thread-private. </p><span id="more"></span><h2 id="Thread-Sharing-Areas"><a href="#Thread-Sharing-Areas" class="headerlink" title="Thread Sharing Areas"></a>Thread Sharing Areas</h2><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>Heap is created as soon as the JVM is started. </p><p>It occupies the biggest memory, and also it is the main area that GC focuses on.</p><p>The only function of this area is “Storing the instances”, which means everything that was created by “new” key word in Java will be stored in this area, including array since array is also created by new.</p><p>Note that lots of articles say Heap itself is further divided into different areas: Eden Space, Survivor Space, Old Gen, this is not fully correct. All these terms come from another angle – Garbage Collection.  From memory model aspect,  there is only heap.</p><h3 id="Method-Area"><a href="#Method-Area" class="headerlink" title="Method Area"></a>Method Area</h3><p>In one word, Method Area is used to store all class-related information such as fields, constant, static variables, etc.</p><p>One thing to be noticed is the Runtime Constant Pool. Generally speaking, the so called runtime constant pool is part of space inside Method Area that used to store Constant Pool of the class file.</p><p>To be more specific, when java compiles .java file into bytecode, there are strict rules about the bytecode structure. It contains different units and the order between them are constant. Among these units, one thing is the constant pool.</p><p>Constant pool records the information about constant and symbolic references of the class file. One thing to be notice is that “Constant Pool” is part of the .class file. Runtime Constant Pool is part of the Memory where the constant Pool is stored.</p><h2 id="Thread-Private-Areas"><a href="#Thread-Private-Areas" class="headerlink" title="Thread Private Areas"></a>Thread Private Areas</h2><h3 id="Program-Counter"><a href="#Program-Counter" class="headerlink" title="Program Counter"></a>Program Counter</h3><p>Similar to the CS register, indicating the line number of current instructions that is being implemented.</p><p>It is thread private because when current thread is interrupt and out of CPU, PC can help CPU knows which instruction to be run when the threads come back.</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>Lifecycle is same as thread.</p><p>Every thread has a stack, and every time a method is called, a stack frame will be created in the stack.</p><p>The process that a method is implemented is the process that the stack frame being pushed and pop out to/from the stack.</p><p>Stack Frame records following information:</p><ul><li><p>Local Variable Table: </p><p>function parameters, local variables.</p></li><li><p>Operand Stack: </p><p>When we do calculation operations inside a method, it is actually done by Operand Stack.</p><p>It is also used to pass the parameters when calling another method inside a method.</p></li><li><p>Dynamic Linking</p><p>When a method A calling method B,  JVM needs to know where B is stored. </p><p>This information is stored in the Constant Pool.</p></li></ul><h3 id="Native-Method-Stack"><a href="#Native-Method-Stack" class="headerlink" title="Native Method Stack"></a>Native Method Stack</h3><p>Same as Stack, but used by native methods.</p><p>Created by Shain at 2021/12/1, Melbourne, Australia.</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Foundation(1) -- IoC and IoC Container</title>
      <link href="/2021/10/31/springFoundation-1-Ioc/"/>
      <url>/2021/10/31/springFoundation-1-Ioc/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Foundation-1-–-IoC-and-IoC-Container"><a href="#Spring-Foundation-1-–-IoC-and-IoC-Container" class="headerlink" title="Spring Foundation(1) – IoC and IoC Container"></a>Spring Foundation(1) – IoC and IoC Container</h1><h3 id="1-What-is-IoC"><a href="#1-What-is-IoC" class="headerlink" title="1. What is IoC?"></a>1. What is IoC?</h3><p><code>IoC</code> (inversion of control) is an abstract concept, meaning that let “high level” decides “low level” instead of “low level” decides “high level”. </p><p>In software engineering, this abstract concept normally just refers to let a “third party” to help us <code>create objects and manage their dependencies</code> , in which context the so called third party is  the <code>IoC Container</code> and the process that IoC Container helps to create and manage objects is called <code>Dependency Injection(DI)</code>.</p><span id="more"></span><h3 id="2-Why-we-need-it"><a href="#2-Why-we-need-it" class="headerlink" title="2. Why we need it"></a>2. Why we need it</h3><p>This might be confusing, so let’s see an example to have a clearer understanding. Imagine one scenario that you have 5 classes A - E, where Class A depends on Class B and Class B depends on Class C and so on.  Let’s say Class E has a field e, so in Class D there should be a line of code <code>new ClassE(&#39;valueOfe&#39;)</code>, then in Class C, still you have to have a line of code saying <code>new ClassD(&#39;valueOfe&#39;)</code> right? Same thing happens in Class A and B.  To be more specific:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Class E&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> e;</span><br><span class="line">    E(<span class="keyword">int</span> e)&#123;</span><br><span class="line">        <span class="keyword">this</span>.e = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class D&#123;</span><br><span class="line"><span class="keyword">private</span> E objectE;</span><br><span class="line">    D(<span class="keyword">int</span> valueOfIntE)&#123;</span><br><span class="line">        <span class="keyword">this</span>.objectE = <span class="keyword">new</span> E(valueOfIntE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class C&#123;</span><br><span class="line">    <span class="keyword">private</span> D objectD;</span><br><span class="line">    C(<span class="keyword">int</span> valueofIntE)&#123;</span><br><span class="line">        <span class="keyword">this</span>.objectD = <span class="keyword">new</span> D(valueOfIntE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>This means that when the value of <code>e</code> in Class E changes, all the classes need to be updated. In reality development, this kind of dependency can be hundreds of classes, which is almost impossible to be manually updated one by one. </p><p>This is why IoC, or we can say, DI is useful.  In the above code, the inconvenience comes from the problem that the highest level Class A depends on low level classes, which means that we have to manually new objects in our code. But DI can release us from “newing” objects in our code. Instead, we just need to say what object we require and then the IoC container will give it to us.  In this way, the code would become as following:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Class E&#123;</span><br><span class="line">private int e;</span><br><span class="line">    E(int e)&#123;</span><br><span class="line">        this.e = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class D&#123;</span><br><span class="line">private E objectE;</span><br><span class="line">    D(E e)&#123;</span><br><span class="line">        this.objectE = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class C&#123;</span><br><span class="line">    private D objectD;</span><br><span class="line">    C(D d)&#123;</span><br><span class="line">        this.objectD = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>As seen in the code, after using DI, all the objects is provided by the container. Then if the value of e changes at this time, there is no other objects needed to be updated. And this is the so called “Inversion of Control”, previously the “highest level” Class A depends on low level classes. But now the situation changed, it has become to <code>low level classes are injected to high level Class A</code>.</p><p>The benefit that IoC can give include:  <code>Decoupling</code>, <code>improve code reusable</code>, and <code>improve convenience of unit test</code>.</p><h3 id="3-How-does-it-work"><a href="#3-How-does-it-work" class="headerlink" title="3. How does it work?"></a>3. How does it work?</h3><p>After knowing the why we need IoC in software engineering, there is still one question remains: how does the system know the dependency relationship between objects? Also, how does the system know which class should be managed by it instead of ourselves? In the context of Spring framework, this work is done by the <code>IoC Service Provider</code>.</p><h5 id="IoC-Service-Provider"><a href="#IoC-Service-Provider" class="headerlink" title="IoC Service Provider"></a>IoC Service Provider</h5><p>IoC Service Provider is an abstract concept, and the so called <code>Ioc Container</code> is exactly an IoC Service Provider. It has two main responsibilities: 1) <code>create the object</code>, 2) <code>manage the dependencies between objects</code>.  The basic principle is that we do some configuration works to tell the container what classes need to be managed by it and what’s the dependency relationships between them. Then, the container will help us do the job.</p><p>Three ways of configuration is acceptable in Spring framework: <code>coding</code>, <code>configuration file</code>, or <code>annotation</code>.  Details will be introduced later.</p><h3 id="4-IoC-Container"><a href="#4-IoC-Container" class="headerlink" title="4. IoC Container"></a>4. IoC Container</h3><p>The term container might be confusing and abstract, but it is actually nothing but a running environment. You can say it set of libraries that provides some functions or a context where the application-related information can be automatically managed and stored. </p><p>As discussed earlier, the IoC container is an IoC Service Provider that can manage and create objects, but in fact the IoC container has much more other functionalities such as providing the AOP support, Object Lifecycle Management, and Thread Management. Spring framework provides two types of containers : <code>BeanFactory</code> and <code>ApplicationContext</code>.</p><h5 id="BeanFactory-VS-ApplicationContext"><a href="#BeanFactory-VS-ApplicationContext" class="headerlink" title="BeanFactory VS ApplicationContext"></a>BeanFactory VS ApplicationContext</h5><p>The term “bean” just means nothing special but object. So the work of BeanFactory is just generate beans to you. There are only two responsibilities it has: <code>create beans</code> and <code>manage dependencies</code>.  In other words, you only need to tell the BeanFactory what object you want, and it will return it for you.</p><p>BeanFactory uses <code>Lazy-load</code> strategy, which means <strong>it initiates object and inject dependencies to it only when this object is needed</strong>. This means <strong>BeanFactory has a faster speed when the container is initiated.</strong>  Therefore, <strong>in the situation where the resource is limited and there is no strict requirement about the functionalities, BeanFactory would be a good choice.</strong></p><p>In contrast, ApplicationContext has more functionalities than BeanFactory. <strong>It indirectly inherent from the BeanFactory and thus has all functionalities that BeanFactory has, and provide more functionalities such as Event Publish etc.</strong>  Unlike BeanFactory, <strong>ApplicationContext initiate all objects and inject dependencies to them as soon as the container is initiated, which means the initiating speed is lower.</strong>  <strong>It fits the situation where you have enough resource and has needs more functionalities.</strong></p><p>Created by Shain Melbourne, Australia.</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoC </tag>
            
            <tag> IoC Container </tag>
            
            <tag> BeanFactory </tag>
            
            <tag> ApplicationContext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>For LeiHeHe</title>
      <link href="/2021/10/30/test/"/>
      <url>/2021/10/30/test/</url>
      
        <content type="html"><![CDATA[<p>Thank my dear dear dear favorite girl <a href="https://leihehehe.github.io/">Leiheee’s</a> help during the construction of this blog❤❤❤❤😍😍😍😍🐱‍🐉🐱‍🐉🐱‍🐉🐱‍🐉.</p>]]></content>
      
      
      <categories>
          
          <category> for_leihee </category>
          
      </categories>
      
      
        <tags>
            
            <tag> for_Leiheee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法思想及排序算法的实现与对比</title>
      <link href="/2021/10/30/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"/>
      <url>/2021/10/30/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="算法思想及排序算法的实现与对比"><a href="#算法思想及排序算法的实现与对比" class="headerlink" title="算法思想及排序算法的实现与对比"></a>算法思想及排序算法的实现与对比</h2><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="循环和递归"><a href="#循环和递归" class="headerlink" title="循环和递归"></a>循环和递归</h5><p>​    递归即大问题分解成小问题，但递归通常效率较低，通常表现为<code>时间</code>， <code>空间</code> 均效率低下。 </p><p>​    递归时由于重复调用方法自身，每次调用方法时皆需在内存栈中分配空间以保存参数，返回地址及临时变量 因此需大量空间，而压栈弹栈皆需要时间。</p><p>​    </p><p>​    写递归代码切忌人脑模拟电脑思考进栈出栈细节。</p><p>​    只需确认三点：</p><p>​    终止条件 + 函数功能 + 函数方程；</p><p>​    此外思考函数方程时，也需注意终止条件中的返回值是什么。</p><p>​    </p><p>​    同时， 别太死板的觉得 终止条件一定要 “同时包含互斥条件的两方”， 例如 offer 13. 只需判断当前格子不可选时，return 0即可。 无需包含 当前格子是最后一     个可选的时返回1， 观察函数方程即可理解。</p><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><p>​    特点：</p><p>​        （1）某个问题可以分解成小问题 ，并且所问为求最优解（关于是否要求最优解不绝对 ）。</p><p>​        （2）把小问题的最优解组合起来能得到整体最优解，则通常可用动态规划。 </p><p>​        （3） 小问题之间有重叠的子问题（即如果用递归则需要算很多重复的值）。</p><p>​    分析动态规划时的思考方式与递归类似，因为都是大问题分解小问题。 </p><p>​    动态规划则为<code>自上而下</code> 方式思考解体思路。而用代码实现时则用<code>自下而上</code> 的方式解决问题，同时利用数据<code>存储小问题的解</code>然后组合小问题的解以得到整个问题的解， 熟练后可抛弃数组，仅用几个变量    存储有用的解</p><h5 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h5><p>​    若某个问题用动态规划的思路思考以后， 发现<code>分解子问题时存在某种特定条件能使得结果一定为最优解</code>， 则此时应思考贪心算法</p><h5 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h5><p>可理解为<code>有剪枝的穷举</code>，其从解决问题每一步的多个选项里系统的选择一个可行的方案。</p><p>适合用于解决<code>有多个步骤组成，且每个步骤有多个选项的问题</code>。</p><p>回溯法解决问题的过程，可以近似理解为“遍历”一颗树的过程。 树中的每一个level 即一个步骤，每个node即一个选项。</p><p>当遍历至一个节点时，发现结果已不可能满足条件，则可放弃该节点返回至上一层节点。</p><p>同理，若发现一个节点的所有子节点均不满足条件时，则同样返回至上一层节点。</p><p>而返回至上一层节点时，若发现上一层中所有节点均已被遍历过，则再次返回至上一层节点。</p><p>如果所有节点（即路径）均已遍历且无符合条件的路径，则r</p><p>对于在二维数组中搜索路径的问题，如迷宫或棋盘，以及搜索可行解的问题，则通常可用<code>回溯法</code>。 而回溯法通常可用递归的方式求解。 递归又可用栈来实现。</p><span id="more"></span><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h5 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h5><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>对于在一个<code>排序的，或部分排序的数组</code>中<code>查找一个数字</code>，或<code>统计一个数字出现的次数</code>的问题，均可尝试使用二分查找</p><h5 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h5><p>优： 效率最高， 时间复杂度O(1)</p><p>缺： 空间效率较低，需额外空间维护哈希表</p><h5 id="二叉排序树查找（即二叉查找树）"><a href="#二叉排序树查找（即二叉查找树）" class="headerlink" title="二叉排序树查找（即二叉查找树）"></a>二叉排序树查找（即二叉查找树）</h5><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h5 id="Code-and-Commitment"><a href="#Code-and-Commitment" class="headerlink" title="Code and Commitment:"></a>Code and Commitment:</h5><p><strong>冒泡排序</strong></p><p>空间复杂度O(1)</p><p>时间复杂度：</p><p>最低O(n): 即input is already sorted</p><p>最高O(n^2): input is fully reversed</p><p>平均： O(n^2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">nums: <span class="type">List</span></span>) -&gt; <span class="type">List</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    # wrong answer writen in 2021-11-29</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for i in range(len(nums)-1, 0):</span></span><br><span class="line"><span class="string">        for j in range(len(nums)-1, i):</span></span><br><span class="line"><span class="string">            if nums[j] &lt; nums[j - 1]:</span></span><br><span class="line"><span class="string">                nums[j], nums[j - 1] = nums[j - 1], nums[j]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    冒泡排序：</span></span><br><span class="line"><span class="string">        冒泡排序每次交换相邻的两个元素</span></span><br><span class="line"><span class="string">        每次循环结束后， 最大或最小的元素均被挪动至数组结尾，因此， “循环条件为每次上层循环结束后，下层循环的终点应右移”</span></span><br><span class="line"><span class="string">        上述错误产生原因在与对第一层循环i的理解有误， i的作用是使第二曾循环j的终点至右移， 因为i每加1， 则意味着有 1 个元素已经被</span></span><br><span class="line"><span class="string">        放置在正确位置， 也即数组的后i个元素已经排好序无需在比较</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>]:</span><br><span class="line">                nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort_optimized</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        原版本代码对于一个已排序的数组，依旧需循环 n + n-1 + n-2 + ... 次， which is unefficient</span></span><br><span class="line"><span class="string">        可加入标志为实现对于一个已排序的数组，时间复杂度为O(n)</span></span><br><span class="line"><span class="string">        关于标志位：</span></span><br><span class="line"><span class="string">        即记录每次内层循环中是否发生换位，如果没发生，则代表每两个数据间大小顺序均已符合条件，即数组已排好序</span></span><br><span class="line"><span class="string">    :param nums:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">        no_swap = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>]:</span><br><span class="line">                nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br><span class="line">                no_swap = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> no_swap <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><strong>插入排序</strong></p><p>时间复杂度总是O(n^2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">nums</span>) -&gt; <span class="type">List</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Overall, insertion sort virtually divide the array into two parts: sorted part and unsorted part</span></span><br><span class="line"><span class="string">        It get one of elements in unsorted part every time and insert it into the right position of sorted part</span></span><br><span class="line"><span class="string">        During the insertion process, we need to move the elements in sorted part to make space for the newly inserted one</span></span><br><span class="line"><span class="string">        E.g. sorted part:</span></span><br><span class="line"><span class="string">        index:    0, 1, 2, 3, 4</span></span><br><span class="line"><span class="string">        element:  1, 3, 4, 5, 6      to be inserted: 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Then:</span></span><br><span class="line"><span class="string">        index:    0, 1, 2, 3, 4, 5</span></span><br><span class="line"><span class="string">        element:  1,  , 3, 4, 5, 6</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="comment"># i 的左侧为已经排好序的元素， 右侧为未排序元素</span></span><br><span class="line">    <span class="comment"># 每当i右移1位，则取一个未排序元素并将其插入i的左侧为其排序</span></span><br><span class="line">    <span class="comment"># i的值从1开始</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        current = nums[i]</span><br><span class="line">        j = i</span><br><span class="line">        <span class="keyword">while</span> current &lt; nums[j-<span class="number">1</span>] <span class="keyword">and</span> j &gt;= <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 已排序元素右移为新元素腾位置</span></span><br><span class="line">            nums[j] = nums[j-<span class="number">1</span>]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        nums[j] = current</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><strong>快速排序</strong></p><p>平均时间复杂度： O(nlogn)</p><p>最佳：  O(nlogn)</p><p>最坏： O(n^2)</p><p>快排的复杂度好坏取决于pivot的选取，而因为一般实现快排时通常选取最左或最有的元素为pivot，因此在这种情况下，当输入数组为完全倒序时时间复杂度最坏，为O(n^2)</p><p>Specifically, 当pivot总是为数组正中的元素时，那么时间复杂度最佳，为O(n^2)。 原因在于，如果我们将整个排序过程想成一颗树的话，那么此时递归树是平衡的，也即深度最小。 但若对完全反序的数组排序，那么递归树则为完全倾斜的，即深度最高，递归次数最多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">nums: <span class="type">List</span></span>) -&gt; <span class="type">List</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    快排的关键即为pivot找位置</span></span><br><span class="line"><span class="string">    pivot：</span></span><br><span class="line"><span class="string">    可以选取任意元素为pivot</span></span><br><span class="line"><span class="string">    pivot左侧皆比其小，右侧皆比其大</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    为pivot选好位置后，即可将pivot左右两侧的数据分为两个数组（pivot无需再包括在其中）</span></span><br><span class="line"><span class="string">    然后对两个sub arrays 进行同样操作即可</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    注意理解quick_sort_recursive的终止条件</span></span><br><span class="line"><span class="string">    e.g. [1,3,2] ==&gt; pivot = index1 ==&gt; left array = [1], right array = [2]</span></span><br><span class="line"><span class="string">    以[1] 为例， 此时[1] 调用partition后返回的pivot index 为0，</span></span><br><span class="line"><span class="string">    此时再传参至下列代码时</span></span><br><span class="line"><span class="string">    quick_sort_recursive(left, pivot_index - 1, li)</span></span><br><span class="line"><span class="string">    quick_sort_recursive(pivot_index + 1, right, li)</span></span><br><span class="line"><span class="string">    left = 0, right = -1;</span></span><br><span class="line"><span class="string">    left = 1, right = 0</span></span><br><span class="line"><span class="string">    触发终止条件</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">left, right, li</span>):</span></span><br><span class="line">        pivot = li[left]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 之所以加上left &lt; right 的条件，是为了防止始终没找到符合条件的元素</span></span><br><span class="line">            <span class="comment"># 比如到了index 0 还比pivot大， 再减1 则会变-1， 访问li[-1] 便会报错</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[right] &gt;= pivot:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 至此，找到了比pivot小的元素， 所以应将其移到左侧，在第一次循环时， left指针指向的值为pivot，</span></span><br><span class="line">            <span class="comment"># 当使left = right时， 数组中重复了一个right指针指向的元素，丢失了pivot</span></span><br><span class="line">            <span class="comment"># 但是pivot的值已经保存在pivot变量中，所以最后会被还原</span></span><br><span class="line">            li[left] = li[right]</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[left] &lt;= pivot:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 而当程序运行至此，数组中重复的right值会被消除，因为此时right指针没动，还指向原本right值的位置，当进行此赋值操作时，</span></span><br><span class="line">            <span class="comment"># right值变成了left。 此时数组中又重复了一个left值</span></span><br><span class="line">            li[right] = li[left]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此时，left指针指向应该消除的重复的left值，并且此时left指针必定会移动到pivot应该所在的位置</span></span><br><span class="line">        <span class="comment"># 所以进行该赋值操作后，整个数组中元素没有重复，没有丢失，且pivot被转移到应在的位置</span></span><br><span class="line">        li[left] = pivot</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort_recursive</span>(<span class="params">left, right, li</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pivot_index = partition(left, right, li)</span><br><span class="line">        quick_sort_recursive(left, pivot_index - <span class="number">1</span>, li)</span><br><span class="line">        quick_sort_recursive(pivot_index + <span class="number">1</span>, right, li)</span><br><span class="line"></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    quick_sort_recursive(left, right, nums)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><strong>归并排序</strong></p><p>时间复杂度总是O(nlogn)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">nums</span>) -&gt; <span class="type">List</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        归并即先将数组持续对半分，直到分解成单个元素</span></span><br><span class="line"><span class="string">        再依次进行merge</span></span><br><span class="line"><span class="string">        典型的分治思想</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left: <span class="type">List</span>, right: <span class="type">List</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        2021-11-29</span></span><br><span class="line"><span class="string">        错误代码：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        temp_result = []</span></span><br><span class="line"><span class="string">        while len(n1) != 0 and len(n2) != 0:</span></span><br><span class="line"><span class="string">            # 错误1.1：</span></span><br><span class="line"><span class="string">            en1 = n1.pop(0)</span></span><br><span class="line"><span class="string">            en2 = n2.pop(0)</span></span><br><span class="line"><span class="string">            if en1 &gt; en2:</span></span><br><span class="line"><span class="string">                # 错误1.2：</span></span><br><span class="line"><span class="string">                temp_result.append(en2)</span></span><br><span class="line"><span class="string">                temp_result.append(en1)</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                # 错误1：</span></span><br><span class="line"><span class="string">                temp_result.append(en1)</span></span><br><span class="line"><span class="string">                temp_result.append(en2)</span></span><br><span class="line"><span class="string">        # 错误2</span></span><br><span class="line"><span class="string">        temp_result.append(en1)</span></span><br><span class="line"><span class="string">        temp_result.append(en2)</span></span><br><span class="line"><span class="string">        return temp_result</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        错1：</span></span><br><span class="line"><span class="string">        根源在于，在merge时，有可能n1中的元素全部比n2中的小，即n1全部添加进了result以后n2才开始pop</span></span><br><span class="line"><span class="string">        1.1 and 1.2 皆时assume n1， n2 必是轮流进一个， 即n1进一个后n2就进一个</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        错2：</span></span><br><span class="line"><span class="string">        此处以为添加剩余元素，不可直接append， 这样会使整个列表变成result中的一个元素，即[..., []] 而非 [...,...]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]:</span><br><span class="line">                result.append(left.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(right.pop(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        result += left</span><br><span class="line">        result += right</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort_entry</span>(<span class="params">nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            merge_sort_entry 本身的函数功能 “仅仅为分解而已！” ， 看终止条件的设置即可理解。（写递归代码时需确定： 终止条件，函数功能，递归方程）</span></span><br><span class="line"><span class="string">            merge排序的工作是merge function做的</span></span><br><span class="line"><span class="string">        :param nums:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">        mid = <span class="built_in">len</span>(nums)//<span class="number">2</span></span><br><span class="line">        left = nums[:mid]</span><br><span class="line">        right = nums[mid:]</span><br><span class="line">        <span class="keyword">return</span> merge(merge_sort_entry(left), merge_sort_entry(right))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge_sort_entry(nums)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sorting algorithm &amp; algorithm general </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
